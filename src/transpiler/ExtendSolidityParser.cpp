
// Generated from ExtendSolidity.g4 by ANTLR 4.12.0


#include "ExtendSolidityListener.h"
#include "ExtendSolidityVisitor.h"

#include "ExtendSolidityParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct ExtendSolidityParserStaticData final {
  ExtendSolidityParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  ExtendSolidityParserStaticData(const ExtendSolidityParserStaticData&) = delete;
  ExtendSolidityParserStaticData(ExtendSolidityParserStaticData&&) = delete;
  ExtendSolidityParserStaticData& operator=(const ExtendSolidityParserStaticData&) = delete;
  ExtendSolidityParserStaticData& operator=(ExtendSolidityParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag extendsolidityParserOnceFlag;
ExtendSolidityParserStaticData *extendsolidityParserStaticData = nullptr;

void extendsolidityParserInitialize() {
  assert(extendsolidityParserStaticData == nullptr);
  auto staticData = std::make_unique<ExtendSolidityParserStaticData>(
    std::vector<std::string>{
      "sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version", 
      "versionOperator", "versionConstraint", "importDeclaration", "importDirective", 
      "natSpec", "contractDefinition", "inheritanceSpecifier", "contractPart", 
      "stateVariableDeclaration", "usingForDeclaration", "structDefinition", 
      "constructorDefinition", "modifierDefinition", "modifierInvocation", 
      "functionDefinition", "functionDescriptor", "returnParameters", "modifierList", 
      "overrideSpecifier", "accessiblity", "eventDefinition", "enumValue", 
      "enumDefinition", "parameterList", "parameter", "eventParameterList", 
      "eventParameter", "functionTypeParameterList", "functionTypeParameter", 
      "variableDeclaration", "typeName", "userDefinedTypeName", "mapping", 
      "functionTypeName", "storageLocation", "stateMutability", "block", 
      "statement", "expressionStatement", "ifStatement", "ifWithBlock", 
      "elseWithBlock", "elseIfWithBlock", "whileStatement", "forStatement", 
      "inlineAssemblyStatement", "doWhileStatement", "continueStatement", 
      "breakStatement", "returnStatement", "throwStatement", "emitStatement", 
      "relayStatement", "relayLambdaDefinition", "relayLambdaParameter", 
      "relayScope", "variableDeclarationStatement", "localVariableDeclaration", 
      "variableDeclarationList", "moreVariableDeclaration", "identifierList", 
      "moreIdentifier", "elementaryTypeName", "expression", "postOperator", 
      "preOperator", "midOperator", "primaryExpression", "matchedParentheses", 
      "expressionList", "nameValueList", "nameValue", "functionCallArguments", 
      "functionCall", "assemblyBlock", "assemblyItem", "assemblyExpression", 
      "assemblyCall", "assemblyLocalDefinition", "assemblyAssignment", "assemblyIdentifierOrList", 
      "assemblyIdentifierList", "assemblyStackAssignment", "labelDefinition", 
      "assemblySwitch", "assemblyCase", "assemblyFunctionDefinition", "assemblyFunctionReturns", 
      "assemblyFor", "assemblyIf", "assemblyLiteral", "subAssembly", "tupleExpression", 
      "bracketTupleExpression", "moreExpression", "paranthesesTupleExpression", 
      "typeNameExpression", "numberLiteral", "identifier", "scope", "accessSpecifier"
    },
    std::vector<std::string>{
      "", "'pragma'", "';'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='", 
      "'='", "'as'", "'import'", "'*'", "'from'", "'{'", "','", "'}'", "'contract'", 
      "'interface'", "'library'", "'is'", "'('", "')'", "'using'", "'for'", 
      "'struct'", "'modifier'", "'function'", "'returns'", "'event'", "'enum'", 
      "'['", "']'", "'address'", "'.'", "'mapping'", "'=>'", "'memory'", 
      "'storage'", "'calldata'", "'if'", "'else'", "'while'", "'assembly'", 
      "'do'", "'return'", "'throw'", "'emit'", "'var'", "'@'", "'global'", 
      "'locals'", "'bool'", "'string'", "'byte'", "'new'", "'\\u003F'", 
      "':'", "'++'", "'--'", "'+'", "'-'", "'!'", "'after'", "'delete'", 
      "'**'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'=='", "'!='", 
      "'&&'", "'||'", "'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", 
      "'-='", "'*='", "'/='", "'%='", "'let'", "':='", "'=:'", "'switch'", 
      "'case'", "'default'", "'->'", "'local'", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "'anonymous'", "'break'", "'constant'", 
      "'continue'", "'external'", "'indexed'", "'internal'", "'payable'", 
      "'private'", "'public'", "'pure'", "'type'", "'view'", "'relay'", 
      "'constructor'", "'override'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "NatSpecSingleLine", "NatSpecMultiLine", 
      "VersionLiteral", "BooleanLiteral", "DecimalNumber", "HexNumber", 
      "Int", "Uint", "Byte", "Fixed", "Ufixed", "NumberUnit", "HexLiteral", 
      "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", 
      "ContinueKeyword", "ExternalKeyword", "IndexedKeyword", "InternalKeyword", 
      "PayableKeyword", "PrivateKeyword", "PublicKeyword", "PureKeyword", 
      "TypeKeyword", "ViewKeyword", "RelayKeyword", "ConstructorKeyword", 
      "OverrideKeyword", "Identifier", "StringLiteral", "WS", "COMMENT", 
      "LINE_COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,128,1082,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,1,0,1,0,1,0,5,0,216,8,0,10,0,12,0,219,9,0,1,0,1,0,1,
  	1,1,1,1,1,1,1,1,1,1,2,1,2,1,3,1,3,3,3,232,8,3,1,4,1,4,3,4,236,8,4,1,5,
  	1,5,1,6,3,6,241,8,6,1,6,1,6,1,7,1,7,1,7,3,7,248,8,7,1,8,1,8,1,8,1,8,3,
  	8,254,8,8,1,8,1,8,1,8,1,8,3,8,260,8,8,1,8,1,8,3,8,264,8,8,1,8,1,8,1,8,
  	1,8,1,8,1,8,1,8,1,8,5,8,274,8,8,10,8,12,8,277,9,8,1,8,1,8,1,8,1,8,1,8,
  	3,8,284,8,8,1,9,1,9,1,10,3,10,289,8,10,1,10,1,10,1,10,1,10,1,10,1,10,
  	5,10,297,8,10,10,10,12,10,300,9,10,3,10,302,8,10,1,10,1,10,5,10,306,8,
  	10,10,10,12,10,309,9,10,1,10,1,10,1,11,1,11,1,11,3,11,316,8,11,1,11,3,
  	11,319,8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,329,8,12,1,13,
  	1,13,3,13,333,8,13,1,13,5,13,336,8,13,10,13,12,13,339,9,13,1,13,1,13,
  	1,13,3,13,344,8,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,3,14,353,8,14,1,
  	14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,5,15,365,8,15,10,15,12,
  	15,368,9,15,3,15,370,8,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,17,1,17,
  	1,17,3,17,382,8,17,1,17,1,17,1,18,1,18,1,18,3,18,389,8,18,1,18,3,18,392,
  	8,18,1,19,3,19,395,8,19,1,19,1,19,1,19,3,19,400,8,19,1,19,1,19,3,19,404,
  	8,19,1,19,1,19,3,19,408,8,19,1,20,1,20,3,20,412,8,20,1,20,3,20,415,8,
  	20,1,21,1,21,1,21,1,22,1,22,1,22,1,22,5,22,424,8,22,10,22,12,22,427,9,
  	22,1,23,1,23,1,24,1,24,1,25,3,25,434,8,25,1,25,1,25,1,25,1,25,3,25,440,
  	8,25,1,25,1,25,1,26,1,26,1,27,1,27,1,27,1,27,3,27,450,8,27,1,27,1,27,
  	5,27,454,8,27,10,27,12,27,457,9,27,1,27,1,27,1,28,1,28,1,28,1,28,5,28,
  	465,8,28,10,28,12,28,468,9,28,3,28,470,8,28,1,28,1,28,1,29,1,29,3,29,
  	476,8,29,1,29,3,29,479,8,29,1,30,1,30,1,30,1,30,5,30,485,8,30,10,30,12,
  	30,488,9,30,3,30,490,8,30,1,30,1,30,1,31,1,31,3,31,496,8,31,1,31,3,31,
  	499,8,31,1,32,1,32,1,32,1,32,5,32,505,8,32,10,32,12,32,508,9,32,3,32,
  	510,8,32,1,32,1,32,1,33,1,33,3,33,516,8,33,1,34,1,34,3,34,520,8,34,1,
  	34,1,34,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,531,8,35,1,35,1,35,1,
  	35,3,35,536,8,35,1,35,5,35,539,8,35,10,35,12,35,542,9,35,1,36,1,36,1,
  	36,5,36,547,8,36,10,36,12,36,550,9,36,1,37,1,37,1,37,1,37,1,37,1,37,1,
  	37,1,38,1,38,1,38,1,38,1,38,5,38,564,8,38,10,38,12,38,567,9,38,1,38,1,
  	38,3,38,571,8,38,1,39,1,39,1,40,1,40,1,41,1,41,5,41,579,8,41,10,41,12,
  	41,582,9,41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,
  	42,1,42,1,42,1,42,1,42,3,42,600,8,42,1,43,1,43,1,43,1,44,1,44,5,44,607,
  	8,44,10,44,12,44,610,9,44,1,44,3,44,613,8,44,1,45,1,45,1,45,1,45,1,45,
  	1,45,1,46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,48,1,48,1,48,
  	1,48,1,48,1,48,1,49,1,49,1,49,1,49,3,49,641,8,49,1,49,1,49,3,49,645,8,
  	49,1,49,1,49,3,49,649,8,49,1,49,1,49,1,49,1,50,1,50,3,50,656,8,50,1,50,
  	1,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,53,1,53,
  	1,53,1,54,1,54,3,54,676,8,54,1,54,1,54,1,55,1,55,1,55,1,56,1,56,1,56,
  	1,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,696,8,57,1,58,
  	1,58,1,58,1,58,5,58,702,8,58,10,58,12,58,705,9,58,3,58,707,8,58,1,58,
  	1,58,1,58,1,59,1,59,3,59,714,8,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,
  	722,8,59,1,60,1,60,1,60,1,60,3,60,728,8,60,1,61,1,61,1,61,1,62,1,62,1,
  	62,1,62,1,62,1,62,1,62,3,62,740,8,62,1,62,1,62,3,62,744,8,62,1,63,3,63,
  	747,8,63,1,63,5,63,750,8,63,10,63,12,63,753,9,63,1,64,1,64,3,64,757,8,
  	64,1,65,1,65,5,65,761,8,65,10,65,12,65,764,9,65,1,65,3,65,767,8,65,1,
  	65,1,65,1,66,3,66,772,8,66,1,66,1,66,1,67,1,67,1,68,1,68,1,68,1,68,1,
  	68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,3,68,795,
  	8,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,
  	1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,
  	1,68,1,68,1,68,1,68,1,68,1,68,5,68,830,8,68,10,68,12,68,833,9,68,1,69,
  	1,69,1,70,1,70,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,3,72,847,8,72,
  	1,72,1,72,1,72,1,72,3,72,853,8,72,3,72,855,8,72,1,73,1,73,1,73,1,74,1,
  	74,1,74,5,74,863,8,74,10,74,12,74,866,9,74,1,75,1,75,1,75,5,75,871,8,
  	75,10,75,12,75,874,9,75,1,75,3,75,877,8,75,1,76,1,76,1,76,1,76,1,77,1,
  	77,3,77,885,8,77,1,77,1,77,3,77,889,8,77,3,77,891,8,77,1,78,1,78,1,78,
  	1,78,1,78,1,79,1,79,5,79,900,8,79,10,79,12,79,903,9,79,1,79,1,79,1,80,
  	1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,
  	1,80,1,80,3,80,924,8,80,1,81,1,81,3,81,928,8,81,1,82,1,82,1,82,1,82,3,
  	82,934,8,82,1,82,1,82,3,82,938,8,82,1,82,1,82,5,82,942,8,82,10,82,12,
  	82,945,9,82,1,82,3,82,948,8,82,1,83,1,83,1,83,1,83,3,83,954,8,83,1,84,
  	1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,3,85,965,8,85,1,86,1,86,1,86,
  	5,86,970,8,86,10,86,12,86,973,9,86,1,87,1,87,1,87,1,88,1,88,1,88,1,89,
  	1,89,1,89,5,89,984,8,89,10,89,12,89,987,9,89,1,90,1,90,1,90,1,90,1,90,
  	1,90,3,90,995,8,90,1,91,1,91,1,91,1,91,3,91,1001,8,91,1,91,1,91,3,91,
  	1005,8,91,1,91,1,91,1,92,1,92,1,92,1,93,1,93,1,93,3,93,1015,8,93,1,93,
  	1,93,1,93,3,93,1020,8,93,1,93,1,93,1,94,1,94,1,94,1,94,1,95,1,95,1,96,
  	1,96,1,96,1,96,1,97,1,97,3,97,1036,8,97,1,98,1,98,3,98,1040,8,98,1,98,
  	5,98,1043,8,98,10,98,12,98,1046,9,98,1,98,1,98,1,99,1,99,3,99,1052,8,
  	99,1,100,1,100,1,100,1,100,5,100,1058,8,100,10,100,12,100,1061,9,100,
  	3,100,1063,8,100,1,100,1,100,1,101,1,101,3,101,1069,8,101,1,102,1,102,
  	3,102,1073,8,102,1,103,1,103,1,104,1,104,1,104,1,105,1,105,1,105,0,2,
  	70,136,106,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,
  	42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
  	88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
  	126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,
  	162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,
  	198,200,202,204,206,208,210,0,15,1,0,3,9,1,0,94,95,1,0,17,19,3,0,112,
  	112,114,114,116,117,1,0,37,39,4,0,110,110,115,115,118,118,120,120,4,0,
  	33,33,48,48,52,54,100,104,1,0,58,59,2,0,4,4,58,64,5,0,3,3,5,9,12,12,60,
  	61,65,85,3,0,98,99,106,106,125,125,1,0,98,99,3,0,13,13,39,39,124,124,
  	4,0,33,33,50,50,93,93,101,101,3,0,110,110,114,114,116,117,1150,0,217,
  	1,0,0,0,2,222,1,0,0,0,4,227,1,0,0,0,6,231,1,0,0,0,8,233,1,0,0,0,10,237,
  	1,0,0,0,12,240,1,0,0,0,14,244,1,0,0,0,16,283,1,0,0,0,18,285,1,0,0,0,20,
  	288,1,0,0,0,22,312,1,0,0,0,24,328,1,0,0,0,26,330,1,0,0,0,28,347,1,0,0,
  	0,30,356,1,0,0,0,32,373,1,0,0,0,34,378,1,0,0,0,36,385,1,0,0,0,38,394,
  	1,0,0,0,40,414,1,0,0,0,42,416,1,0,0,0,44,425,1,0,0,0,46,428,1,0,0,0,48,
  	430,1,0,0,0,50,433,1,0,0,0,52,443,1,0,0,0,54,445,1,0,0,0,56,460,1,0,0,
  	0,58,473,1,0,0,0,60,480,1,0,0,0,62,493,1,0,0,0,64,500,1,0,0,0,66,513,
  	1,0,0,0,68,517,1,0,0,0,70,530,1,0,0,0,72,543,1,0,0,0,74,551,1,0,0,0,76,
  	558,1,0,0,0,78,572,1,0,0,0,80,574,1,0,0,0,82,576,1,0,0,0,84,599,1,0,0,
  	0,86,601,1,0,0,0,88,604,1,0,0,0,90,614,1,0,0,0,92,620,1,0,0,0,94,623,
  	1,0,0,0,96,630,1,0,0,0,98,636,1,0,0,0,100,653,1,0,0,0,102,659,1,0,0,0,
  	104,667,1,0,0,0,106,670,1,0,0,0,108,673,1,0,0,0,110,679,1,0,0,0,112,682,
  	1,0,0,0,114,686,1,0,0,0,116,697,1,0,0,0,118,721,1,0,0,0,120,723,1,0,0,
  	0,122,729,1,0,0,0,124,739,1,0,0,0,126,746,1,0,0,0,128,754,1,0,0,0,130,
  	758,1,0,0,0,132,771,1,0,0,0,134,775,1,0,0,0,136,794,1,0,0,0,138,834,1,
  	0,0,0,140,836,1,0,0,0,142,838,1,0,0,0,144,854,1,0,0,0,146,856,1,0,0,0,
  	148,859,1,0,0,0,150,867,1,0,0,0,152,878,1,0,0,0,154,890,1,0,0,0,156,892,
  	1,0,0,0,158,897,1,0,0,0,160,923,1,0,0,0,162,927,1,0,0,0,164,933,1,0,0,
  	0,166,949,1,0,0,0,168,955,1,0,0,0,170,964,1,0,0,0,172,966,1,0,0,0,174,
  	974,1,0,0,0,176,977,1,0,0,0,178,980,1,0,0,0,180,994,1,0,0,0,182,996,1,
  	0,0,0,184,1008,1,0,0,0,186,1011,1,0,0,0,188,1023,1,0,0,0,190,1027,1,0,
  	0,0,192,1029,1,0,0,0,194,1035,1,0,0,0,196,1037,1,0,0,0,198,1049,1,0,0,
  	0,200,1053,1,0,0,0,202,1068,1,0,0,0,204,1070,1,0,0,0,206,1074,1,0,0,0,
  	208,1076,1,0,0,0,210,1079,1,0,0,0,212,216,3,2,1,0,213,216,3,16,8,0,214,
  	216,3,20,10,0,215,212,1,0,0,0,215,213,1,0,0,0,215,214,1,0,0,0,216,219,
  	1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,1,0,0,0,219,217,1,0,0,
  	0,220,221,5,0,0,1,221,1,1,0,0,0,222,223,5,1,0,0,223,224,3,4,2,0,224,225,
  	3,6,3,0,225,226,5,2,0,0,226,3,1,0,0,0,227,228,3,206,103,0,228,5,1,0,0,
  	0,229,232,3,8,4,0,230,232,3,136,68,0,231,229,1,0,0,0,231,230,1,0,0,0,
  	232,7,1,0,0,0,233,235,3,12,6,0,234,236,3,12,6,0,235,234,1,0,0,0,235,236,
  	1,0,0,0,236,9,1,0,0,0,237,238,7,0,0,0,238,11,1,0,0,0,239,241,3,10,5,0,
  	240,239,1,0,0,0,240,241,1,0,0,0,241,242,1,0,0,0,242,243,5,96,0,0,243,
  	13,1,0,0,0,244,247,3,206,103,0,245,246,5,10,0,0,246,248,3,206,103,0,247,
  	245,1,0,0,0,247,248,1,0,0,0,248,15,1,0,0,0,249,250,5,11,0,0,250,253,5,
  	125,0,0,251,252,5,10,0,0,252,254,3,206,103,0,253,251,1,0,0,0,253,254,
  	1,0,0,0,254,255,1,0,0,0,255,284,5,2,0,0,256,259,5,11,0,0,257,260,5,12,
  	0,0,258,260,3,206,103,0,259,257,1,0,0,0,259,258,1,0,0,0,260,263,1,0,0,
  	0,261,262,5,10,0,0,262,264,3,206,103,0,263,261,1,0,0,0,263,264,1,0,0,
  	0,264,265,1,0,0,0,265,266,5,13,0,0,266,267,5,125,0,0,267,284,5,2,0,0,
  	268,269,5,11,0,0,269,270,5,14,0,0,270,275,3,14,7,0,271,272,5,15,0,0,272,
  	274,3,14,7,0,273,271,1,0,0,0,274,277,1,0,0,0,275,273,1,0,0,0,275,276,
  	1,0,0,0,276,278,1,0,0,0,277,275,1,0,0,0,278,279,5,16,0,0,279,280,5,13,
  	0,0,280,281,5,125,0,0,281,282,5,2,0,0,282,284,1,0,0,0,283,249,1,0,0,0,
  	283,256,1,0,0,0,283,268,1,0,0,0,284,17,1,0,0,0,285,286,7,1,0,0,286,19,
  	1,0,0,0,287,289,3,18,9,0,288,287,1,0,0,0,288,289,1,0,0,0,289,290,1,0,
  	0,0,290,291,7,2,0,0,291,301,3,206,103,0,292,293,5,20,0,0,293,298,3,22,
  	11,0,294,295,5,15,0,0,295,297,3,22,11,0,296,294,1,0,0,0,297,300,1,0,0,
  	0,298,296,1,0,0,0,298,299,1,0,0,0,299,302,1,0,0,0,300,298,1,0,0,0,301,
  	292,1,0,0,0,301,302,1,0,0,0,302,303,1,0,0,0,303,307,5,14,0,0,304,306,
  	3,24,12,0,305,304,1,0,0,0,306,309,1,0,0,0,307,305,1,0,0,0,307,308,1,0,
  	0,0,308,310,1,0,0,0,309,307,1,0,0,0,310,311,5,16,0,0,311,21,1,0,0,0,312,
  	318,3,72,36,0,313,315,5,21,0,0,314,316,3,148,74,0,315,314,1,0,0,0,315,
  	316,1,0,0,0,316,317,1,0,0,0,317,319,5,22,0,0,318,313,1,0,0,0,318,319,
  	1,0,0,0,319,23,1,0,0,0,320,329,3,26,13,0,321,329,3,28,14,0,322,329,3,
  	30,15,0,323,329,3,32,16,0,324,329,3,34,17,0,325,329,3,38,19,0,326,329,
  	3,50,25,0,327,329,3,54,27,0,328,320,1,0,0,0,328,321,1,0,0,0,328,322,1,
  	0,0,0,328,323,1,0,0,0,328,324,1,0,0,0,328,325,1,0,0,0,328,326,1,0,0,0,
  	328,327,1,0,0,0,329,25,1,0,0,0,330,332,3,70,35,0,331,333,3,208,104,0,
  	332,331,1,0,0,0,332,333,1,0,0,0,333,337,1,0,0,0,334,336,3,210,105,0,335,
  	334,1,0,0,0,336,339,1,0,0,0,337,335,1,0,0,0,337,338,1,0,0,0,338,340,1,
  	0,0,0,339,337,1,0,0,0,340,343,3,206,103,0,341,342,5,9,0,0,342,344,3,136,
  	68,0,343,341,1,0,0,0,343,344,1,0,0,0,344,345,1,0,0,0,345,346,5,2,0,0,
  	346,27,1,0,0,0,347,348,5,23,0,0,348,349,3,206,103,0,349,352,5,24,0,0,
  	350,353,5,12,0,0,351,353,3,70,35,0,352,350,1,0,0,0,352,351,1,0,0,0,353,
  	354,1,0,0,0,354,355,5,2,0,0,355,29,1,0,0,0,356,357,5,25,0,0,357,358,3,
  	206,103,0,358,369,5,14,0,0,359,360,3,68,34,0,360,366,5,2,0,0,361,362,
  	3,68,34,0,362,363,5,2,0,0,363,365,1,0,0,0,364,361,1,0,0,0,365,368,1,0,
  	0,0,366,364,1,0,0,0,366,367,1,0,0,0,367,370,1,0,0,0,368,366,1,0,0,0,369,
  	359,1,0,0,0,369,370,1,0,0,0,370,371,1,0,0,0,371,372,5,16,0,0,372,31,1,
  	0,0,0,373,374,5,122,0,0,374,375,3,56,28,0,375,376,3,44,22,0,376,377,3,
  	82,41,0,377,33,1,0,0,0,378,379,5,26,0,0,379,381,3,206,103,0,380,382,3,
  	56,28,0,381,380,1,0,0,0,381,382,1,0,0,0,382,383,1,0,0,0,383,384,3,82,
  	41,0,384,35,1,0,0,0,385,391,3,206,103,0,386,388,5,21,0,0,387,389,3,148,
  	74,0,388,387,1,0,0,0,388,389,1,0,0,0,389,390,1,0,0,0,390,392,5,22,0,0,
  	391,386,1,0,0,0,391,392,1,0,0,0,392,37,1,0,0,0,393,395,3,18,9,0,394,393,
  	1,0,0,0,394,395,1,0,0,0,395,396,1,0,0,0,396,397,3,40,20,0,397,399,3,56,
  	28,0,398,400,3,208,104,0,399,398,1,0,0,0,399,400,1,0,0,0,400,401,1,0,
  	0,0,401,403,3,44,22,0,402,404,3,42,21,0,403,402,1,0,0,0,403,404,1,0,0,
  	0,404,407,1,0,0,0,405,408,5,2,0,0,406,408,3,82,41,0,407,405,1,0,0,0,407,
  	406,1,0,0,0,408,39,1,0,0,0,409,411,5,27,0,0,410,412,3,206,103,0,411,410,
  	1,0,0,0,411,412,1,0,0,0,412,415,1,0,0,0,413,415,5,122,0,0,414,409,1,0,
  	0,0,414,413,1,0,0,0,415,41,1,0,0,0,416,417,5,28,0,0,417,418,3,56,28,0,
  	418,43,1,0,0,0,419,424,3,36,18,0,420,424,3,80,40,0,421,424,3,48,24,0,
  	422,424,3,46,23,0,423,419,1,0,0,0,423,420,1,0,0,0,423,421,1,0,0,0,423,
  	422,1,0,0,0,424,427,1,0,0,0,425,423,1,0,0,0,425,426,1,0,0,0,426,45,1,
  	0,0,0,427,425,1,0,0,0,428,429,5,123,0,0,429,47,1,0,0,0,430,431,7,3,0,
  	0,431,49,1,0,0,0,432,434,3,18,9,0,433,432,1,0,0,0,433,434,1,0,0,0,434,
  	435,1,0,0,0,435,436,5,29,0,0,436,437,3,206,103,0,437,439,3,60,30,0,438,
  	440,5,108,0,0,439,438,1,0,0,0,439,440,1,0,0,0,440,441,1,0,0,0,441,442,
  	5,2,0,0,442,51,1,0,0,0,443,444,3,206,103,0,444,53,1,0,0,0,445,446,5,30,
  	0,0,446,447,3,206,103,0,447,449,5,14,0,0,448,450,3,52,26,0,449,448,1,
  	0,0,0,449,450,1,0,0,0,450,455,1,0,0,0,451,452,5,15,0,0,452,454,3,52,26,
  	0,453,451,1,0,0,0,454,457,1,0,0,0,455,453,1,0,0,0,455,456,1,0,0,0,456,
  	458,1,0,0,0,457,455,1,0,0,0,458,459,5,16,0,0,459,55,1,0,0,0,460,469,5,
  	21,0,0,461,466,3,58,29,0,462,463,5,15,0,0,463,465,3,58,29,0,464,462,1,
  	0,0,0,465,468,1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,467,470,1,0,0,0,
  	468,466,1,0,0,0,469,461,1,0,0,0,469,470,1,0,0,0,470,471,1,0,0,0,471,472,
  	5,22,0,0,472,57,1,0,0,0,473,475,3,70,35,0,474,476,3,78,39,0,475,474,1,
  	0,0,0,475,476,1,0,0,0,476,478,1,0,0,0,477,479,3,206,103,0,478,477,1,0,
  	0,0,478,479,1,0,0,0,479,59,1,0,0,0,480,489,5,21,0,0,481,486,3,62,31,0,
  	482,483,5,15,0,0,483,485,3,62,31,0,484,482,1,0,0,0,485,488,1,0,0,0,486,
  	484,1,0,0,0,486,487,1,0,0,0,487,490,1,0,0,0,488,486,1,0,0,0,489,481,1,
  	0,0,0,489,490,1,0,0,0,490,491,1,0,0,0,491,492,5,22,0,0,492,61,1,0,0,0,
  	493,495,3,70,35,0,494,496,5,113,0,0,495,494,1,0,0,0,495,496,1,0,0,0,496,
  	498,1,0,0,0,497,499,3,206,103,0,498,497,1,0,0,0,498,499,1,0,0,0,499,63,
  	1,0,0,0,500,509,5,21,0,0,501,506,3,66,33,0,502,503,5,15,0,0,503,505,3,
  	66,33,0,504,502,1,0,0,0,505,508,1,0,0,0,506,504,1,0,0,0,506,507,1,0,0,
  	0,507,510,1,0,0,0,508,506,1,0,0,0,509,501,1,0,0,0,509,510,1,0,0,0,510,
  	511,1,0,0,0,511,512,5,22,0,0,512,65,1,0,0,0,513,515,3,70,35,0,514,516,
  	3,78,39,0,515,514,1,0,0,0,515,516,1,0,0,0,516,67,1,0,0,0,517,519,3,70,
  	35,0,518,520,3,78,39,0,519,518,1,0,0,0,519,520,1,0,0,0,520,521,1,0,0,
  	0,521,522,3,206,103,0,522,69,1,0,0,0,523,524,6,35,-1,0,524,531,3,134,
  	67,0,525,531,3,72,36,0,526,531,3,74,37,0,527,531,3,76,38,0,528,529,5,
  	33,0,0,529,531,5,115,0,0,530,523,1,0,0,0,530,525,1,0,0,0,530,526,1,0,
  	0,0,530,527,1,0,0,0,530,528,1,0,0,0,531,540,1,0,0,0,532,533,10,3,0,0,
  	533,535,5,31,0,0,534,536,3,136,68,0,535,534,1,0,0,0,535,536,1,0,0,0,536,
  	537,1,0,0,0,537,539,5,32,0,0,538,532,1,0,0,0,539,542,1,0,0,0,540,538,
  	1,0,0,0,540,541,1,0,0,0,541,71,1,0,0,0,542,540,1,0,0,0,543,548,3,206,
  	103,0,544,545,5,34,0,0,545,547,3,206,103,0,546,544,1,0,0,0,547,550,1,
  	0,0,0,548,546,1,0,0,0,548,549,1,0,0,0,549,73,1,0,0,0,550,548,1,0,0,0,
  	551,552,5,35,0,0,552,553,5,21,0,0,553,554,3,134,67,0,554,555,5,36,0,0,
  	555,556,3,70,35,0,556,557,5,22,0,0,557,75,1,0,0,0,558,559,5,27,0,0,559,
  	565,3,64,32,0,560,564,5,114,0,0,561,564,5,112,0,0,562,564,3,80,40,0,563,
  	560,1,0,0,0,563,561,1,0,0,0,563,562,1,0,0,0,564,567,1,0,0,0,565,563,1,
  	0,0,0,565,566,1,0,0,0,566,570,1,0,0,0,567,565,1,0,0,0,568,569,5,28,0,
  	0,569,571,3,64,32,0,570,568,1,0,0,0,570,571,1,0,0,0,571,77,1,0,0,0,572,
  	573,7,4,0,0,573,79,1,0,0,0,574,575,7,5,0,0,575,81,1,0,0,0,576,580,5,14,
  	0,0,577,579,3,84,42,0,578,577,1,0,0,0,579,582,1,0,0,0,580,578,1,0,0,0,
  	580,581,1,0,0,0,581,583,1,0,0,0,582,580,1,0,0,0,583,584,5,16,0,0,584,
  	83,1,0,0,0,585,600,3,88,44,0,586,600,3,96,48,0,587,600,3,98,49,0,588,
  	600,3,100,50,0,589,600,3,102,51,0,590,600,3,104,52,0,591,600,3,106,53,
  	0,592,600,3,108,54,0,593,600,3,110,55,0,594,600,3,112,56,0,595,600,3,
  	114,57,0,596,600,3,122,61,0,597,600,3,86,43,0,598,600,3,82,41,0,599,585,
  	1,0,0,0,599,586,1,0,0,0,599,587,1,0,0,0,599,588,1,0,0,0,599,589,1,0,0,
  	0,599,590,1,0,0,0,599,591,1,0,0,0,599,592,1,0,0,0,599,593,1,0,0,0,599,
  	594,1,0,0,0,599,595,1,0,0,0,599,596,1,0,0,0,599,597,1,0,0,0,599,598,1,
  	0,0,0,600,85,1,0,0,0,601,602,3,136,68,0,602,603,5,2,0,0,603,87,1,0,0,
  	0,604,608,3,90,45,0,605,607,3,94,47,0,606,605,1,0,0,0,607,610,1,0,0,0,
  	608,606,1,0,0,0,608,609,1,0,0,0,609,612,1,0,0,0,610,608,1,0,0,0,611,613,
  	3,92,46,0,612,611,1,0,0,0,612,613,1,0,0,0,613,89,1,0,0,0,614,615,5,40,
  	0,0,615,616,5,21,0,0,616,617,3,136,68,0,617,618,5,22,0,0,618,619,3,82,
  	41,0,619,91,1,0,0,0,620,621,5,41,0,0,621,622,3,82,41,0,622,93,1,0,0,0,
  	623,624,5,41,0,0,624,625,5,40,0,0,625,626,5,21,0,0,626,627,3,136,68,0,
  	627,628,5,22,0,0,628,629,3,82,41,0,629,95,1,0,0,0,630,631,5,42,0,0,631,
  	632,5,21,0,0,632,633,3,136,68,0,633,634,5,22,0,0,634,635,3,84,42,0,635,
  	97,1,0,0,0,636,637,5,24,0,0,637,640,5,21,0,0,638,641,3,124,62,0,639,641,
  	3,136,68,0,640,638,1,0,0,0,640,639,1,0,0,0,640,641,1,0,0,0,641,642,1,
  	0,0,0,642,644,5,2,0,0,643,645,3,136,68,0,644,643,1,0,0,0,644,645,1,0,
  	0,0,645,646,1,0,0,0,646,648,5,2,0,0,647,649,3,136,68,0,648,647,1,0,0,
  	0,648,649,1,0,0,0,649,650,1,0,0,0,650,651,5,22,0,0,651,652,3,82,41,0,
  	652,99,1,0,0,0,653,655,5,43,0,0,654,656,5,125,0,0,655,654,1,0,0,0,655,
  	656,1,0,0,0,656,657,1,0,0,0,657,658,3,158,79,0,658,101,1,0,0,0,659,660,
  	5,44,0,0,660,661,3,84,42,0,661,662,5,42,0,0,662,663,5,21,0,0,663,664,
  	3,136,68,0,664,665,5,22,0,0,665,666,5,2,0,0,666,103,1,0,0,0,667,668,5,
  	111,0,0,668,669,5,2,0,0,669,105,1,0,0,0,670,671,5,109,0,0,671,672,5,2,
  	0,0,672,107,1,0,0,0,673,675,5,45,0,0,674,676,3,136,68,0,675,674,1,0,0,
  	0,675,676,1,0,0,0,676,677,1,0,0,0,677,678,5,2,0,0,678,109,1,0,0,0,679,
  	680,5,46,0,0,680,681,5,2,0,0,681,111,1,0,0,0,682,683,5,47,0,0,683,684,
  	3,156,78,0,684,685,5,2,0,0,685,113,1,0,0,0,686,687,5,121,0,0,687,695,
  	3,120,60,0,688,689,3,206,103,0,689,690,5,21,0,0,690,691,3,154,77,0,691,
  	692,5,22,0,0,692,693,5,2,0,0,693,696,1,0,0,0,694,696,3,116,58,0,695,688,
  	1,0,0,0,695,694,1,0,0,0,696,115,1,0,0,0,697,706,5,21,0,0,698,703,3,118,
  	59,0,699,700,5,15,0,0,700,702,3,118,59,0,701,699,1,0,0,0,702,705,1,0,
  	0,0,703,701,1,0,0,0,703,704,1,0,0,0,704,707,1,0,0,0,705,703,1,0,0,0,706,
  	698,1,0,0,0,706,707,1,0,0,0,707,708,1,0,0,0,708,709,5,22,0,0,709,710,
  	3,82,41,0,710,117,1,0,0,0,711,714,5,48,0,0,712,714,3,70,35,0,713,711,
  	1,0,0,0,713,712,1,0,0,0,714,715,1,0,0,0,715,716,3,206,103,0,716,717,5,
  	9,0,0,717,718,3,136,68,0,718,722,1,0,0,0,719,720,5,3,0,0,720,722,3,206,
  	103,0,721,713,1,0,0,0,721,719,1,0,0,0,722,119,1,0,0,0,723,727,5,49,0,
  	0,724,728,5,50,0,0,725,728,5,51,0,0,726,728,3,136,68,0,727,724,1,0,0,
  	0,727,725,1,0,0,0,727,726,1,0,0,0,728,121,1,0,0,0,729,730,3,124,62,0,
  	730,731,5,2,0,0,731,123,1,0,0,0,732,733,5,48,0,0,733,740,3,130,65,0,734,
  	740,3,68,34,0,735,736,5,21,0,0,736,737,3,126,63,0,737,738,5,22,0,0,738,
  	740,1,0,0,0,739,732,1,0,0,0,739,734,1,0,0,0,739,735,1,0,0,0,740,743,1,
  	0,0,0,741,742,5,9,0,0,742,744,3,136,68,0,743,741,1,0,0,0,743,744,1,0,
  	0,0,744,125,1,0,0,0,745,747,3,68,34,0,746,745,1,0,0,0,746,747,1,0,0,0,
  	747,751,1,0,0,0,748,750,3,128,64,0,749,748,1,0,0,0,750,753,1,0,0,0,751,
  	749,1,0,0,0,751,752,1,0,0,0,752,127,1,0,0,0,753,751,1,0,0,0,754,756,5,
  	15,0,0,755,757,3,68,34,0,756,755,1,0,0,0,756,757,1,0,0,0,757,129,1,0,
  	0,0,758,762,5,21,0,0,759,761,3,132,66,0,760,759,1,0,0,0,761,764,1,0,0,
  	0,762,760,1,0,0,0,762,763,1,0,0,0,763,766,1,0,0,0,764,762,1,0,0,0,765,
  	767,3,206,103,0,766,765,1,0,0,0,766,767,1,0,0,0,767,768,1,0,0,0,768,769,
  	5,22,0,0,769,131,1,0,0,0,770,772,3,206,103,0,771,770,1,0,0,0,771,772,
  	1,0,0,0,772,773,1,0,0,0,773,774,5,15,0,0,774,133,1,0,0,0,775,776,7,6,
  	0,0,776,135,1,0,0,0,777,778,6,68,-1,0,778,779,5,21,0,0,779,780,3,136,
  	68,0,780,781,5,22,0,0,781,782,6,68,-1,0,782,795,1,0,0,0,783,784,3,140,
  	70,0,784,785,3,136,68,5,785,786,6,68,-1,0,786,795,1,0,0,0,787,788,5,55,
  	0,0,788,789,3,70,35,0,789,790,6,68,-1,0,790,795,1,0,0,0,791,792,3,144,
  	72,0,792,793,6,68,-1,0,793,795,1,0,0,0,794,777,1,0,0,0,794,783,1,0,0,
  	0,794,787,1,0,0,0,794,791,1,0,0,0,795,831,1,0,0,0,796,797,10,3,0,0,797,
  	798,3,142,71,0,798,799,3,136,68,4,799,800,6,68,-1,0,800,830,1,0,0,0,801,
  	802,10,2,0,0,802,803,5,56,0,0,803,804,3,136,68,0,804,805,5,57,0,0,805,
  	806,3,136,68,3,806,807,6,68,-1,0,807,830,1,0,0,0,808,809,10,10,0,0,809,
  	810,3,138,69,0,810,811,6,68,-1,0,811,830,1,0,0,0,812,813,10,9,0,0,813,
  	814,5,31,0,0,814,815,3,136,68,0,815,816,5,32,0,0,816,817,6,68,-1,0,817,
  	830,1,0,0,0,818,819,10,8,0,0,819,820,5,21,0,0,820,821,3,154,77,0,821,
  	822,5,22,0,0,822,823,6,68,-1,0,823,830,1,0,0,0,824,825,10,7,0,0,825,826,
  	5,34,0,0,826,827,3,206,103,0,827,828,6,68,-1,0,828,830,1,0,0,0,829,796,
  	1,0,0,0,829,801,1,0,0,0,829,808,1,0,0,0,829,812,1,0,0,0,829,818,1,0,0,
  	0,829,824,1,0,0,0,830,833,1,0,0,0,831,829,1,0,0,0,831,832,1,0,0,0,832,
  	137,1,0,0,0,833,831,1,0,0,0,834,835,7,7,0,0,835,139,1,0,0,0,836,837,7,
  	8,0,0,837,141,1,0,0,0,838,839,7,9,0,0,839,143,1,0,0,0,840,855,5,97,0,
  	0,841,855,3,204,102,0,842,855,5,106,0,0,843,855,5,125,0,0,844,846,3,206,
  	103,0,845,847,3,146,73,0,846,845,1,0,0,0,846,847,1,0,0,0,847,855,1,0,
  	0,0,848,855,5,119,0,0,849,855,3,194,97,0,850,852,3,202,101,0,851,853,
  	3,146,73,0,852,851,1,0,0,0,852,853,1,0,0,0,853,855,1,0,0,0,854,840,1,
  	0,0,0,854,841,1,0,0,0,854,842,1,0,0,0,854,843,1,0,0,0,854,844,1,0,0,0,
  	854,848,1,0,0,0,854,849,1,0,0,0,854,850,1,0,0,0,855,145,1,0,0,0,856,857,
  	5,31,0,0,857,858,5,32,0,0,858,147,1,0,0,0,859,864,3,136,68,0,860,861,
  	5,15,0,0,861,863,3,136,68,0,862,860,1,0,0,0,863,866,1,0,0,0,864,862,1,
  	0,0,0,864,865,1,0,0,0,865,149,1,0,0,0,866,864,1,0,0,0,867,872,3,152,76,
  	0,868,869,5,15,0,0,869,871,3,152,76,0,870,868,1,0,0,0,871,874,1,0,0,0,
  	872,870,1,0,0,0,872,873,1,0,0,0,873,876,1,0,0,0,874,872,1,0,0,0,875,877,
  	5,15,0,0,876,875,1,0,0,0,876,877,1,0,0,0,877,151,1,0,0,0,878,879,3,206,
  	103,0,879,880,5,57,0,0,880,881,3,136,68,0,881,153,1,0,0,0,882,884,5,14,
  	0,0,883,885,3,150,75,0,884,883,1,0,0,0,884,885,1,0,0,0,885,886,1,0,0,
  	0,886,891,5,16,0,0,887,889,3,148,74,0,888,887,1,0,0,0,888,889,1,0,0,0,
  	889,891,1,0,0,0,890,882,1,0,0,0,890,888,1,0,0,0,891,155,1,0,0,0,892,893,
  	3,136,68,0,893,894,5,21,0,0,894,895,3,154,77,0,895,896,5,22,0,0,896,157,
  	1,0,0,0,897,901,5,14,0,0,898,900,3,160,80,0,899,898,1,0,0,0,900,903,1,
  	0,0,0,901,899,1,0,0,0,901,902,1,0,0,0,902,904,1,0,0,0,903,901,1,0,0,0,
  	904,905,5,16,0,0,905,159,1,0,0,0,906,924,3,206,103,0,907,924,3,158,79,
  	0,908,924,3,162,81,0,909,924,3,166,83,0,910,924,3,168,84,0,911,924,3,
  	174,87,0,912,924,3,176,88,0,913,924,3,178,89,0,914,924,3,182,91,0,915,
  	924,3,186,93,0,916,924,3,188,94,0,917,924,5,109,0,0,918,924,5,111,0,0,
  	919,924,3,192,96,0,920,924,3,204,102,0,921,924,5,125,0,0,922,924,5,106,
  	0,0,923,906,1,0,0,0,923,907,1,0,0,0,923,908,1,0,0,0,923,909,1,0,0,0,923,
  	910,1,0,0,0,923,911,1,0,0,0,923,912,1,0,0,0,923,913,1,0,0,0,923,914,1,
  	0,0,0,923,915,1,0,0,0,923,916,1,0,0,0,923,917,1,0,0,0,923,918,1,0,0,0,
  	923,919,1,0,0,0,923,920,1,0,0,0,923,921,1,0,0,0,923,922,1,0,0,0,924,161,
  	1,0,0,0,925,928,3,164,82,0,926,928,3,190,95,0,927,925,1,0,0,0,927,926,
  	1,0,0,0,928,163,1,0,0,0,929,934,5,45,0,0,930,934,5,33,0,0,931,934,5,54,
  	0,0,932,934,3,206,103,0,933,929,1,0,0,0,933,930,1,0,0,0,933,931,1,0,0,
  	0,933,932,1,0,0,0,934,947,1,0,0,0,935,937,5,21,0,0,936,938,3,162,81,0,
  	937,936,1,0,0,0,937,938,1,0,0,0,938,943,1,0,0,0,939,940,5,15,0,0,940,
  	942,3,162,81,0,941,939,1,0,0,0,942,945,1,0,0,0,943,941,1,0,0,0,943,944,
  	1,0,0,0,944,946,1,0,0,0,945,943,1,0,0,0,946,948,5,22,0,0,947,935,1,0,
  	0,0,947,948,1,0,0,0,948,165,1,0,0,0,949,950,5,86,0,0,950,953,3,170,85,
  	0,951,952,5,87,0,0,952,954,3,162,81,0,953,951,1,0,0,0,953,954,1,0,0,0,
  	954,167,1,0,0,0,955,956,3,170,85,0,956,957,5,87,0,0,957,958,3,162,81,
  	0,958,169,1,0,0,0,959,965,3,206,103,0,960,961,5,21,0,0,961,962,3,172,
  	86,0,962,963,5,22,0,0,963,965,1,0,0,0,964,959,1,0,0,0,964,960,1,0,0,0,
  	965,171,1,0,0,0,966,971,3,206,103,0,967,968,5,15,0,0,968,970,3,206,103,
  	0,969,967,1,0,0,0,970,973,1,0,0,0,971,969,1,0,0,0,971,972,1,0,0,0,972,
  	173,1,0,0,0,973,971,1,0,0,0,974,975,5,88,0,0,975,976,3,206,103,0,976,
  	175,1,0,0,0,977,978,3,206,103,0,978,979,5,57,0,0,979,177,1,0,0,0,980,
  	981,5,89,0,0,981,985,3,162,81,0,982,984,3,180,90,0,983,982,1,0,0,0,984,
  	987,1,0,0,0,985,983,1,0,0,0,985,986,1,0,0,0,986,179,1,0,0,0,987,985,1,
  	0,0,0,988,989,5,90,0,0,989,990,3,190,95,0,990,991,3,158,79,0,991,995,
  	1,0,0,0,992,993,5,91,0,0,993,995,3,158,79,0,994,988,1,0,0,0,994,992,1,
  	0,0,0,995,181,1,0,0,0,996,997,5,27,0,0,997,998,3,206,103,0,998,1000,5,
  	21,0,0,999,1001,3,172,86,0,1000,999,1,0,0,0,1000,1001,1,0,0,0,1001,1002,
  	1,0,0,0,1002,1004,5,22,0,0,1003,1005,3,184,92,0,1004,1003,1,0,0,0,1004,
  	1005,1,0,0,0,1005,1006,1,0,0,0,1006,1007,3,158,79,0,1007,183,1,0,0,0,
  	1008,1009,5,92,0,0,1009,1010,3,172,86,0,1010,185,1,0,0,0,1011,1014,5,
  	24,0,0,1012,1015,3,158,79,0,1013,1015,3,162,81,0,1014,1012,1,0,0,0,1014,
  	1013,1,0,0,0,1015,1016,1,0,0,0,1016,1019,3,162,81,0,1017,1020,3,158,79,
  	0,1018,1020,3,162,81,0,1019,1017,1,0,0,0,1019,1018,1,0,0,0,1020,1021,
  	1,0,0,0,1021,1022,3,158,79,0,1022,187,1,0,0,0,1023,1024,5,40,0,0,1024,
  	1025,3,162,81,0,1025,1026,3,158,79,0,1026,189,1,0,0,0,1027,1028,7,10,
  	0,0,1028,191,1,0,0,0,1029,1030,5,43,0,0,1030,1031,3,206,103,0,1031,1032,
  	3,158,79,0,1032,193,1,0,0,0,1033,1036,3,196,98,0,1034,1036,3,200,100,
  	0,1035,1033,1,0,0,0,1035,1034,1,0,0,0,1036,195,1,0,0,0,1037,1039,5,21,
  	0,0,1038,1040,3,136,68,0,1039,1038,1,0,0,0,1039,1040,1,0,0,0,1040,1044,
  	1,0,0,0,1041,1043,3,198,99,0,1042,1041,1,0,0,0,1043,1046,1,0,0,0,1044,
  	1042,1,0,0,0,1044,1045,1,0,0,0,1045,1047,1,0,0,0,1046,1044,1,0,0,0,1047,
  	1048,5,22,0,0,1048,197,1,0,0,0,1049,1051,5,15,0,0,1050,1052,3,136,68,
  	0,1051,1050,1,0,0,0,1051,1052,1,0,0,0,1052,199,1,0,0,0,1053,1062,5,31,
  	0,0,1054,1059,3,136,68,0,1055,1056,5,15,0,0,1056,1058,3,136,68,0,1057,
  	1055,1,0,0,0,1058,1061,1,0,0,0,1059,1057,1,0,0,0,1059,1060,1,0,0,0,1060,
  	1063,1,0,0,0,1061,1059,1,0,0,0,1062,1054,1,0,0,0,1062,1063,1,0,0,0,1063,
  	1064,1,0,0,0,1064,1065,5,32,0,0,1065,201,1,0,0,0,1066,1069,3,134,67,0,
  	1067,1069,3,72,36,0,1068,1066,1,0,0,0,1068,1067,1,0,0,0,1069,203,1,0,
  	0,0,1070,1072,7,11,0,0,1071,1073,5,105,0,0,1072,1071,1,0,0,0,1072,1073,
  	1,0,0,0,1073,205,1,0,0,0,1074,1075,7,12,0,0,1075,207,1,0,0,0,1076,1077,
  	5,49,0,0,1077,1078,7,13,0,0,1078,209,1,0,0,0,1079,1080,7,14,0,0,1080,
  	211,1,0,0,0,117,215,217,231,235,240,247,253,259,263,275,283,288,298,301,
  	307,315,318,328,332,337,343,352,366,369,381,388,391,394,399,403,407,411,
  	414,423,425,433,439,449,455,466,469,475,478,486,489,495,498,506,509,515,
  	519,530,535,540,548,563,565,570,580,599,608,612,640,644,648,655,675,695,
  	703,706,713,721,727,739,743,746,751,756,762,766,771,794,829,831,846,852,
  	854,864,872,876,884,888,890,901,923,927,933,937,943,947,953,964,971,985,
  	994,1000,1004,1014,1019,1035,1039,1044,1051,1059,1062,1068,1072
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  extendsolidityParserStaticData = staticData.release();
}

}

ExtendSolidityParser::ExtendSolidityParser(TokenStream *input) : ExtendSolidityParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

ExtendSolidityParser::ExtendSolidityParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  ExtendSolidityParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *extendsolidityParserStaticData->atn, extendsolidityParserStaticData->decisionToDFA, extendsolidityParserStaticData->sharedContextCache, options);
}

ExtendSolidityParser::~ExtendSolidityParser() {
  delete _interpreter;
}

const atn::ATN& ExtendSolidityParser::getATN() const {
  return *extendsolidityParserStaticData->atn;
}

std::string ExtendSolidityParser::getGrammarFileName() const {
  return "ExtendSolidity.g4";
}

const std::vector<std::string>& ExtendSolidityParser::getRuleNames() const {
  return extendsolidityParserStaticData->ruleNames;
}

const dfa::Vocabulary& ExtendSolidityParser::getVocabulary() const {
  return extendsolidityParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView ExtendSolidityParser::getSerializedATN() const {
  return extendsolidityParserStaticData->serializedATN;
}


//----------------- SourceUnitContext ------------------------------------------------------------------

ExtendSolidityParser::SourceUnitContext::SourceUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::SourceUnitContext::EOF() {
  return getToken(ExtendSolidityParser::EOF, 0);
}

std::vector<ExtendSolidityParser::PragmaDirectiveContext *> ExtendSolidityParser::SourceUnitContext::pragmaDirective() {
  return getRuleContexts<ExtendSolidityParser::PragmaDirectiveContext>();
}

ExtendSolidityParser::PragmaDirectiveContext* ExtendSolidityParser::SourceUnitContext::pragmaDirective(size_t i) {
  return getRuleContext<ExtendSolidityParser::PragmaDirectiveContext>(i);
}

std::vector<ExtendSolidityParser::ImportDirectiveContext *> ExtendSolidityParser::SourceUnitContext::importDirective() {
  return getRuleContexts<ExtendSolidityParser::ImportDirectiveContext>();
}

ExtendSolidityParser::ImportDirectiveContext* ExtendSolidityParser::SourceUnitContext::importDirective(size_t i) {
  return getRuleContext<ExtendSolidityParser::ImportDirectiveContext>(i);
}

std::vector<ExtendSolidityParser::ContractDefinitionContext *> ExtendSolidityParser::SourceUnitContext::contractDefinition() {
  return getRuleContexts<ExtendSolidityParser::ContractDefinitionContext>();
}

ExtendSolidityParser::ContractDefinitionContext* ExtendSolidityParser::SourceUnitContext::contractDefinition(size_t i) {
  return getRuleContext<ExtendSolidityParser::ContractDefinitionContext>(i);
}


size_t ExtendSolidityParser::SourceUnitContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleSourceUnit;
}

void ExtendSolidityParser::SourceUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceUnit(this);
}

void ExtendSolidityParser::SourceUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceUnit(this);
}


std::any ExtendSolidityParser::SourceUnitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitSourceUnit(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::SourceUnitContext* ExtendSolidityParser::sourceUnit() {
  SourceUnitContext *_localctx = _tracker.createInstance<SourceUnitContext>(_ctx, getState());
  enterRule(_localctx, 0, ExtendSolidityParser::RuleSourceUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(217);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 919554) != 0) || _la == ExtendSolidityParser::NatSpecSingleLine

    || _la == ExtendSolidityParser::NatSpecMultiLine) {
      setState(215);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ExtendSolidityParser::T__0: {
          setState(212);
          pragmaDirective();
          break;
        }

        case ExtendSolidityParser::T__10: {
          setState(213);
          importDirective();
          break;
        }

        case ExtendSolidityParser::T__16:
        case ExtendSolidityParser::T__17:
        case ExtendSolidityParser::T__18:
        case ExtendSolidityParser::NatSpecSingleLine:
        case ExtendSolidityParser::NatSpecMultiLine: {
          setState(214);
          contractDefinition();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(219);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(220);
    match(ExtendSolidityParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaDirectiveContext ------------------------------------------------------------------

ExtendSolidityParser::PragmaDirectiveContext::PragmaDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::PragmaNameContext* ExtendSolidityParser::PragmaDirectiveContext::pragmaName() {
  return getRuleContext<ExtendSolidityParser::PragmaNameContext>(0);
}

ExtendSolidityParser::PragmaValueContext* ExtendSolidityParser::PragmaDirectiveContext::pragmaValue() {
  return getRuleContext<ExtendSolidityParser::PragmaValueContext>(0);
}


size_t ExtendSolidityParser::PragmaDirectiveContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePragmaDirective;
}

void ExtendSolidityParser::PragmaDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaDirective(this);
}

void ExtendSolidityParser::PragmaDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaDirective(this);
}


std::any ExtendSolidityParser::PragmaDirectiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPragmaDirective(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PragmaDirectiveContext* ExtendSolidityParser::pragmaDirective() {
  PragmaDirectiveContext *_localctx = _tracker.createInstance<PragmaDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 2, ExtendSolidityParser::RulePragmaDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(222);
    match(ExtendSolidityParser::T__0);
    setState(223);
    pragmaName();
    setState(224);
    pragmaValue();
    setState(225);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaNameContext ------------------------------------------------------------------

ExtendSolidityParser::PragmaNameContext::PragmaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::PragmaNameContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::PragmaNameContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePragmaName;
}

void ExtendSolidityParser::PragmaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaName(this);
}

void ExtendSolidityParser::PragmaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaName(this);
}


std::any ExtendSolidityParser::PragmaNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPragmaName(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PragmaNameContext* ExtendSolidityParser::pragmaName() {
  PragmaNameContext *_localctx = _tracker.createInstance<PragmaNameContext>(_ctx, getState());
  enterRule(_localctx, 4, ExtendSolidityParser::RulePragmaName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(227);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaValueContext ------------------------------------------------------------------

ExtendSolidityParser::PragmaValueContext::PragmaValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::VersionContext* ExtendSolidityParser::PragmaValueContext::version() {
  return getRuleContext<ExtendSolidityParser::VersionContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::PragmaValueContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::PragmaValueContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePragmaValue;
}

void ExtendSolidityParser::PragmaValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaValue(this);
}

void ExtendSolidityParser::PragmaValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaValue(this);
}


std::any ExtendSolidityParser::PragmaValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPragmaValue(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PragmaValueContext* ExtendSolidityParser::pragmaValue() {
  PragmaValueContext *_localctx = _tracker.createInstance<PragmaValueContext>(_ctx, getState());
  enterRule(_localctx, 6, ExtendSolidityParser::RulePragmaValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(231);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(229);
      version();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(230);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionContext ------------------------------------------------------------------

ExtendSolidityParser::VersionContext::VersionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::VersionConstraintContext *> ExtendSolidityParser::VersionContext::versionConstraint() {
  return getRuleContexts<ExtendSolidityParser::VersionConstraintContext>();
}

ExtendSolidityParser::VersionConstraintContext* ExtendSolidityParser::VersionContext::versionConstraint(size_t i) {
  return getRuleContext<ExtendSolidityParser::VersionConstraintContext>(i);
}


size_t ExtendSolidityParser::VersionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVersion;
}

void ExtendSolidityParser::VersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersion(this);
}

void ExtendSolidityParser::VersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersion(this);
}


std::any ExtendSolidityParser::VersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVersion(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VersionContext* ExtendSolidityParser::version() {
  VersionContext *_localctx = _tracker.createInstance<VersionContext>(_ctx, getState());
  enterRule(_localctx, 8, ExtendSolidityParser::RuleVersion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    versionConstraint();
    setState(235);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0) || _la == ExtendSolidityParser::VersionLiteral) {
      setState(234);
      versionConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionOperatorContext ------------------------------------------------------------------

ExtendSolidityParser::VersionOperatorContext::VersionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::VersionOperatorContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVersionOperator;
}

void ExtendSolidityParser::VersionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionOperator(this);
}

void ExtendSolidityParser::VersionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionOperator(this);
}


std::any ExtendSolidityParser::VersionOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVersionOperator(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VersionOperatorContext* ExtendSolidityParser::versionOperator() {
  VersionOperatorContext *_localctx = _tracker.createInstance<VersionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 10, ExtendSolidityParser::RuleVersionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(237);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionConstraintContext ------------------------------------------------------------------

ExtendSolidityParser::VersionConstraintContext::VersionConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::VersionConstraintContext::VersionLiteral() {
  return getToken(ExtendSolidityParser::VersionLiteral, 0);
}

ExtendSolidityParser::VersionOperatorContext* ExtendSolidityParser::VersionConstraintContext::versionOperator() {
  return getRuleContext<ExtendSolidityParser::VersionOperatorContext>(0);
}


size_t ExtendSolidityParser::VersionConstraintContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVersionConstraint;
}

void ExtendSolidityParser::VersionConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionConstraint(this);
}

void ExtendSolidityParser::VersionConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionConstraint(this);
}


std::any ExtendSolidityParser::VersionConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVersionConstraint(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VersionConstraintContext* ExtendSolidityParser::versionConstraint() {
  VersionConstraintContext *_localctx = _tracker.createInstance<VersionConstraintContext>(_ctx, getState());
  enterRule(_localctx, 12, ExtendSolidityParser::RuleVersionConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1016) != 0)) {
      setState(239);
      versionOperator();
    }
    setState(242);
    match(ExtendSolidityParser::VersionLiteral);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::ImportDeclarationContext::ImportDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::IdentifierContext *> ExtendSolidityParser::ImportDeclarationContext::identifier() {
  return getRuleContexts<ExtendSolidityParser::IdentifierContext>();
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ImportDeclarationContext::identifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(i);
}


size_t ExtendSolidityParser::ImportDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleImportDeclaration;
}

void ExtendSolidityParser::ImportDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDeclaration(this);
}

void ExtendSolidityParser::ImportDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDeclaration(this);
}


std::any ExtendSolidityParser::ImportDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitImportDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ImportDeclarationContext* ExtendSolidityParser::importDeclaration() {
  ImportDeclarationContext *_localctx = _tracker.createInstance<ImportDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 14, ExtendSolidityParser::RuleImportDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(244);
    identifier();
    setState(247);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__9) {
      setState(245);
      match(ExtendSolidityParser::T__9);
      setState(246);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportDirectiveContext ------------------------------------------------------------------

ExtendSolidityParser::ImportDirectiveContext::ImportDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::ImportDirectiveContext::StringLiteral() {
  return getToken(ExtendSolidityParser::StringLiteral, 0);
}

std::vector<ExtendSolidityParser::IdentifierContext *> ExtendSolidityParser::ImportDirectiveContext::identifier() {
  return getRuleContexts<ExtendSolidityParser::IdentifierContext>();
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ImportDirectiveContext::identifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(i);
}

std::vector<ExtendSolidityParser::ImportDeclarationContext *> ExtendSolidityParser::ImportDirectiveContext::importDeclaration() {
  return getRuleContexts<ExtendSolidityParser::ImportDeclarationContext>();
}

ExtendSolidityParser::ImportDeclarationContext* ExtendSolidityParser::ImportDirectiveContext::importDeclaration(size_t i) {
  return getRuleContext<ExtendSolidityParser::ImportDeclarationContext>(i);
}


size_t ExtendSolidityParser::ImportDirectiveContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleImportDirective;
}

void ExtendSolidityParser::ImportDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportDirective(this);
}

void ExtendSolidityParser::ImportDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportDirective(this);
}


std::any ExtendSolidityParser::ImportDirectiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitImportDirective(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ImportDirectiveContext* ExtendSolidityParser::importDirective() {
  ImportDirectiveContext *_localctx = _tracker.createInstance<ImportDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 16, ExtendSolidityParser::RuleImportDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(283);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(249);
      match(ExtendSolidityParser::T__10);
      setState(250);
      match(ExtendSolidityParser::StringLiteral);
      setState(253);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ExtendSolidityParser::T__9) {
        setState(251);
        match(ExtendSolidityParser::T__9);
        setState(252);
        identifier();
      }
      setState(255);
      match(ExtendSolidityParser::T__1);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(256);
      match(ExtendSolidityParser::T__10);
      setState(259);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ExtendSolidityParser::T__11: {
          setState(257);
          match(ExtendSolidityParser::T__11);
          break;
        }

        case ExtendSolidityParser::T__12:
        case ExtendSolidityParser::T__38:
        case ExtendSolidityParser::Identifier: {
          setState(258);
          identifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(263);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ExtendSolidityParser::T__9) {
        setState(261);
        match(ExtendSolidityParser::T__9);
        setState(262);
        identifier();
      }
      setState(265);
      match(ExtendSolidityParser::T__12);
      setState(266);
      match(ExtendSolidityParser::StringLiteral);
      setState(267);
      match(ExtendSolidityParser::T__1);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(268);
      match(ExtendSolidityParser::T__10);
      setState(269);
      match(ExtendSolidityParser::T__13);
      setState(270);
      importDeclaration();
      setState(275);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(271);
        match(ExtendSolidityParser::T__14);
        setState(272);
        importDeclaration();
        setState(277);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(278);
      match(ExtendSolidityParser::T__15);
      setState(279);
      match(ExtendSolidityParser::T__12);
      setState(280);
      match(ExtendSolidityParser::StringLiteral);
      setState(281);
      match(ExtendSolidityParser::T__1);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NatSpecContext ------------------------------------------------------------------

ExtendSolidityParser::NatSpecContext::NatSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::NatSpecContext::NatSpecSingleLine() {
  return getToken(ExtendSolidityParser::NatSpecSingleLine, 0);
}

tree::TerminalNode* ExtendSolidityParser::NatSpecContext::NatSpecMultiLine() {
  return getToken(ExtendSolidityParser::NatSpecMultiLine, 0);
}


size_t ExtendSolidityParser::NatSpecContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleNatSpec;
}

void ExtendSolidityParser::NatSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNatSpec(this);
}

void ExtendSolidityParser::NatSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNatSpec(this);
}


std::any ExtendSolidityParser::NatSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitNatSpec(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::NatSpecContext* ExtendSolidityParser::natSpec() {
  NatSpecContext *_localctx = _tracker.createInstance<NatSpecContext>(_ctx, getState());
  enterRule(_localctx, 18, ExtendSolidityParser::RuleNatSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(285);
    _la = _input->LA(1);
    if (!(_la == ExtendSolidityParser::NatSpecSingleLine

    || _la == ExtendSolidityParser::NatSpecMultiLine)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContractDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::ContractDefinitionContext::ContractDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ContractDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::NatSpecContext* ExtendSolidityParser::ContractDefinitionContext::natSpec() {
  return getRuleContext<ExtendSolidityParser::NatSpecContext>(0);
}

std::vector<ExtendSolidityParser::InheritanceSpecifierContext *> ExtendSolidityParser::ContractDefinitionContext::inheritanceSpecifier() {
  return getRuleContexts<ExtendSolidityParser::InheritanceSpecifierContext>();
}

ExtendSolidityParser::InheritanceSpecifierContext* ExtendSolidityParser::ContractDefinitionContext::inheritanceSpecifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::InheritanceSpecifierContext>(i);
}

std::vector<ExtendSolidityParser::ContractPartContext *> ExtendSolidityParser::ContractDefinitionContext::contractPart() {
  return getRuleContexts<ExtendSolidityParser::ContractPartContext>();
}

ExtendSolidityParser::ContractPartContext* ExtendSolidityParser::ContractDefinitionContext::contractPart(size_t i) {
  return getRuleContext<ExtendSolidityParser::ContractPartContext>(i);
}


size_t ExtendSolidityParser::ContractDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleContractDefinition;
}

void ExtendSolidityParser::ContractDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContractDefinition(this);
}

void ExtendSolidityParser::ContractDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContractDefinition(this);
}


std::any ExtendSolidityParser::ContractDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitContractDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ContractDefinitionContext* ExtendSolidityParser::contractDefinition() {
  ContractDefinitionContext *_localctx = _tracker.createInstance<ContractDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 20, ExtendSolidityParser::RuleContractDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::NatSpecSingleLine

    || _la == ExtendSolidityParser::NatSpecMultiLine) {
      setState(287);
      natSpec();
    }
    setState(290);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 917504) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(291);
    identifier();
    setState(301);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__19) {
      setState(292);
      match(ExtendSolidityParser::T__19);
      setState(293);
      inheritanceSpecifier();
      setState(298);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(294);
        match(ExtendSolidityParser::T__14);
        setState(295);
        inheritanceSpecifier();
        setState(300);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(303);
    match(ExtendSolidityParser::T__13);
    setState(307);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807266927681536) != 0) || ((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & 1342179267) != 0)) {
      setState(304);
      contractPart();
      setState(309);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(310);
    match(ExtendSolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InheritanceSpecifierContext ------------------------------------------------------------------

ExtendSolidityParser::InheritanceSpecifierContext::InheritanceSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::UserDefinedTypeNameContext* ExtendSolidityParser::InheritanceSpecifierContext::userDefinedTypeName() {
  return getRuleContext<ExtendSolidityParser::UserDefinedTypeNameContext>(0);
}

ExtendSolidityParser::ExpressionListContext* ExtendSolidityParser::InheritanceSpecifierContext::expressionList() {
  return getRuleContext<ExtendSolidityParser::ExpressionListContext>(0);
}


size_t ExtendSolidityParser::InheritanceSpecifierContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleInheritanceSpecifier;
}

void ExtendSolidityParser::InheritanceSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInheritanceSpecifier(this);
}

void ExtendSolidityParser::InheritanceSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInheritanceSpecifier(this);
}


std::any ExtendSolidityParser::InheritanceSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitInheritanceSpecifier(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::InheritanceSpecifierContext* ExtendSolidityParser::inheritanceSpecifier() {
  InheritanceSpecifierContext *_localctx = _tracker.createInstance<InheritanceSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 22, ExtendSolidityParser::RuleInheritanceSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(312);
    userDefinedTypeName();
    setState(318);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__20) {
      setState(313);
      match(ExtendSolidityParser::T__20);
      setState(315);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
        setState(314);
        expressionList();
      }
      setState(317);
      match(ExtendSolidityParser::T__21);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContractPartContext ------------------------------------------------------------------

ExtendSolidityParser::ContractPartContext::ContractPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::StateVariableDeclarationContext* ExtendSolidityParser::ContractPartContext::stateVariableDeclaration() {
  return getRuleContext<ExtendSolidityParser::StateVariableDeclarationContext>(0);
}

ExtendSolidityParser::UsingForDeclarationContext* ExtendSolidityParser::ContractPartContext::usingForDeclaration() {
  return getRuleContext<ExtendSolidityParser::UsingForDeclarationContext>(0);
}

ExtendSolidityParser::StructDefinitionContext* ExtendSolidityParser::ContractPartContext::structDefinition() {
  return getRuleContext<ExtendSolidityParser::StructDefinitionContext>(0);
}

ExtendSolidityParser::ConstructorDefinitionContext* ExtendSolidityParser::ContractPartContext::constructorDefinition() {
  return getRuleContext<ExtendSolidityParser::ConstructorDefinitionContext>(0);
}

ExtendSolidityParser::ModifierDefinitionContext* ExtendSolidityParser::ContractPartContext::modifierDefinition() {
  return getRuleContext<ExtendSolidityParser::ModifierDefinitionContext>(0);
}

ExtendSolidityParser::FunctionDefinitionContext* ExtendSolidityParser::ContractPartContext::functionDefinition() {
  return getRuleContext<ExtendSolidityParser::FunctionDefinitionContext>(0);
}

ExtendSolidityParser::EventDefinitionContext* ExtendSolidityParser::ContractPartContext::eventDefinition() {
  return getRuleContext<ExtendSolidityParser::EventDefinitionContext>(0);
}

ExtendSolidityParser::EnumDefinitionContext* ExtendSolidityParser::ContractPartContext::enumDefinition() {
  return getRuleContext<ExtendSolidityParser::EnumDefinitionContext>(0);
}


size_t ExtendSolidityParser::ContractPartContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleContractPart;
}

void ExtendSolidityParser::ContractPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContractPart(this);
}

void ExtendSolidityParser::ContractPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContractPart(this);
}


std::any ExtendSolidityParser::ContractPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitContractPart(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ContractPartContext* ExtendSolidityParser::contractPart() {
  ContractPartContext *_localctx = _tracker.createInstance<ContractPartContext>(_ctx, getState());
  enterRule(_localctx, 24, ExtendSolidityParser::RuleContractPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(320);
      stateVariableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(321);
      usingForDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(322);
      structDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(323);
      constructorDefinition();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(324);
      modifierDefinition();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(325);
      functionDefinition();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(326);
      eventDefinition();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(327);
      enumDefinition();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StateVariableDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::StateVariableDeclarationContext::StateVariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::StateVariableDeclarationContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::StateVariableDeclarationContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::ScopeContext* ExtendSolidityParser::StateVariableDeclarationContext::scope() {
  return getRuleContext<ExtendSolidityParser::ScopeContext>(0);
}

std::vector<ExtendSolidityParser::AccessSpecifierContext *> ExtendSolidityParser::StateVariableDeclarationContext::accessSpecifier() {
  return getRuleContexts<ExtendSolidityParser::AccessSpecifierContext>();
}

ExtendSolidityParser::AccessSpecifierContext* ExtendSolidityParser::StateVariableDeclarationContext::accessSpecifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::AccessSpecifierContext>(i);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::StateVariableDeclarationContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::StateVariableDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleStateVariableDeclaration;
}

void ExtendSolidityParser::StateVariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStateVariableDeclaration(this);
}

void ExtendSolidityParser::StateVariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStateVariableDeclaration(this);
}


std::any ExtendSolidityParser::StateVariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitStateVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::StateVariableDeclarationContext* ExtendSolidityParser::stateVariableDeclaration() {
  StateVariableDeclarationContext *_localctx = _tracker.createInstance<StateVariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 26, ExtendSolidityParser::RuleStateVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(330);
    typeName(0);
    setState(332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__48) {
      setState(331);
      scope();
    }
    setState(337);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 110) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 110)) & 209) != 0)) {
      setState(334);
      accessSpecifier();
      setState(339);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(340);
    identifier();
    setState(343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__8) {
      setState(341);
      match(ExtendSolidityParser::T__8);
      setState(342);
      expression(0);
    }
    setState(345);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsingForDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::UsingForDeclarationContext::UsingForDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::UsingForDeclarationContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::UsingForDeclarationContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}


size_t ExtendSolidityParser::UsingForDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleUsingForDeclaration;
}

void ExtendSolidityParser::UsingForDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsingForDeclaration(this);
}

void ExtendSolidityParser::UsingForDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsingForDeclaration(this);
}


std::any ExtendSolidityParser::UsingForDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitUsingForDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::UsingForDeclarationContext* ExtendSolidityParser::usingForDeclaration() {
  UsingForDeclarationContext *_localctx = _tracker.createInstance<UsingForDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 28, ExtendSolidityParser::RuleUsingForDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(347);
    match(ExtendSolidityParser::T__22);
    setState(348);
    identifier();
    setState(349);
    match(ExtendSolidityParser::T__23);
    setState(352);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__11: {
        setState(350);
        match(ExtendSolidityParser::T__11);
        break;
      }

      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__26:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__34:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__47:
      case ExtendSolidityParser::T__51:
      case ExtendSolidityParser::T__52:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::Int:
      case ExtendSolidityParser::Uint:
      case ExtendSolidityParser::Byte:
      case ExtendSolidityParser::Fixed:
      case ExtendSolidityParser::Ufixed:
      case ExtendSolidityParser::Identifier: {
        setState(351);
        typeName(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(354);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::StructDefinitionContext::StructDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::StructDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

std::vector<ExtendSolidityParser::VariableDeclarationContext *> ExtendSolidityParser::StructDefinitionContext::variableDeclaration() {
  return getRuleContexts<ExtendSolidityParser::VariableDeclarationContext>();
}

ExtendSolidityParser::VariableDeclarationContext* ExtendSolidityParser::StructDefinitionContext::variableDeclaration(size_t i) {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationContext>(i);
}


size_t ExtendSolidityParser::StructDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleStructDefinition;
}

void ExtendSolidityParser::StructDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStructDefinition(this);
}

void ExtendSolidityParser::StructDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStructDefinition(this);
}


std::any ExtendSolidityParser::StructDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitStructDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::StructDefinitionContext* ExtendSolidityParser::structDefinition() {
  StructDefinitionContext *_localctx = _tracker.createInstance<StructDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 30, ExtendSolidityParser::RuleStructDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    match(ExtendSolidityParser::T__24);
    setState(357);
    identifier();
    setState(358);
    match(ExtendSolidityParser::T__13);
    setState(369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(359);
      variableDeclaration();
      setState(360);
      match(ExtendSolidityParser::T__1);
      setState(366);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 100)) & 16777247) != 0)) {
        setState(361);
        variableDeclaration();
        setState(362);
        match(ExtendSolidityParser::T__1);
        setState(368);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(371);
    match(ExtendSolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::ConstructorDefinitionContext::ConstructorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::ConstructorDefinitionContext::ConstructorKeyword() {
  return getToken(ExtendSolidityParser::ConstructorKeyword, 0);
}

ExtendSolidityParser::ParameterListContext* ExtendSolidityParser::ConstructorDefinitionContext::parameterList() {
  return getRuleContext<ExtendSolidityParser::ParameterListContext>(0);
}

ExtendSolidityParser::ModifierListContext* ExtendSolidityParser::ConstructorDefinitionContext::modifierList() {
  return getRuleContext<ExtendSolidityParser::ModifierListContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::ConstructorDefinitionContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}


size_t ExtendSolidityParser::ConstructorDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleConstructorDefinition;
}

void ExtendSolidityParser::ConstructorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorDefinition(this);
}

void ExtendSolidityParser::ConstructorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorDefinition(this);
}


std::any ExtendSolidityParser::ConstructorDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitConstructorDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ConstructorDefinitionContext* ExtendSolidityParser::constructorDefinition() {
  ConstructorDefinitionContext *_localctx = _tracker.createInstance<ConstructorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 32, ExtendSolidityParser::RuleConstructorDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(373);
    match(ExtendSolidityParser::ConstructorKeyword);
    setState(374);
    parameterList();
    setState(375);
    modifierList();
    setState(376);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::ModifierDefinitionContext::ModifierDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ModifierDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::ModifierDefinitionContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}

ExtendSolidityParser::ParameterListContext* ExtendSolidityParser::ModifierDefinitionContext::parameterList() {
  return getRuleContext<ExtendSolidityParser::ParameterListContext>(0);
}


size_t ExtendSolidityParser::ModifierDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleModifierDefinition;
}

void ExtendSolidityParser::ModifierDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierDefinition(this);
}

void ExtendSolidityParser::ModifierDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierDefinition(this);
}


std::any ExtendSolidityParser::ModifierDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitModifierDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ModifierDefinitionContext* ExtendSolidityParser::modifierDefinition() {
  ModifierDefinitionContext *_localctx = _tracker.createInstance<ModifierDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 34, ExtendSolidityParser::RuleModifierDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    match(ExtendSolidityParser::T__25);
    setState(379);
    identifier();
    setState(381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__20) {
      setState(380);
      parameterList();
    }
    setState(383);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierInvocationContext ------------------------------------------------------------------

ExtendSolidityParser::ModifierInvocationContext::ModifierInvocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ModifierInvocationContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::ExpressionListContext* ExtendSolidityParser::ModifierInvocationContext::expressionList() {
  return getRuleContext<ExtendSolidityParser::ExpressionListContext>(0);
}


size_t ExtendSolidityParser::ModifierInvocationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleModifierInvocation;
}

void ExtendSolidityParser::ModifierInvocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierInvocation(this);
}

void ExtendSolidityParser::ModifierInvocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierInvocation(this);
}


std::any ExtendSolidityParser::ModifierInvocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitModifierInvocation(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ModifierInvocationContext* ExtendSolidityParser::modifierInvocation() {
  ModifierInvocationContext *_localctx = _tracker.createInstance<ModifierInvocationContext>(_ctx, getState());
  enterRule(_localctx, 36, ExtendSolidityParser::RuleModifierInvocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    identifier();
    setState(391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__20) {
      setState(386);
      match(ExtendSolidityParser::T__20);
      setState(388);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
        setState(387);
        expressionList();
      }
      setState(390);
      match(ExtendSolidityParser::T__21);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::FunctionDescriptorContext* ExtendSolidityParser::FunctionDefinitionContext::functionDescriptor() {
  return getRuleContext<ExtendSolidityParser::FunctionDescriptorContext>(0);
}

ExtendSolidityParser::ParameterListContext* ExtendSolidityParser::FunctionDefinitionContext::parameterList() {
  return getRuleContext<ExtendSolidityParser::ParameterListContext>(0);
}

ExtendSolidityParser::ModifierListContext* ExtendSolidityParser::FunctionDefinitionContext::modifierList() {
  return getRuleContext<ExtendSolidityParser::ModifierListContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::FunctionDefinitionContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}

ExtendSolidityParser::NatSpecContext* ExtendSolidityParser::FunctionDefinitionContext::natSpec() {
  return getRuleContext<ExtendSolidityParser::NatSpecContext>(0);
}

ExtendSolidityParser::ScopeContext* ExtendSolidityParser::FunctionDefinitionContext::scope() {
  return getRuleContext<ExtendSolidityParser::ScopeContext>(0);
}

ExtendSolidityParser::ReturnParametersContext* ExtendSolidityParser::FunctionDefinitionContext::returnParameters() {
  return getRuleContext<ExtendSolidityParser::ReturnParametersContext>(0);
}


size_t ExtendSolidityParser::FunctionDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionDefinition;
}

void ExtendSolidityParser::FunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDefinition(this);
}

void ExtendSolidityParser::FunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDefinition(this);
}


std::any ExtendSolidityParser::FunctionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionDefinitionContext* ExtendSolidityParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 38, ExtendSolidityParser::RuleFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(394);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::NatSpecSingleLine

    || _la == ExtendSolidityParser::NatSpecMultiLine) {
      setState(393);
      natSpec();
    }
    setState(396);
    functionDescriptor();
    setState(397);
    parameterList();
    setState(399);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__48) {
      setState(398);
      scope();
    }
    setState(401);
    modifierList();
    setState(403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__27) {
      setState(402);
      returnParameters();
    }
    setState(407);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__1: {
        setState(405);
        match(ExtendSolidityParser::T__1);
        break;
      }

      case ExtendSolidityParser::T__13: {
        setState(406);
        block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDescriptorContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionDescriptorContext::FunctionDescriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::FunctionDescriptorContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::FunctionDescriptorContext::ConstructorKeyword() {
  return getToken(ExtendSolidityParser::ConstructorKeyword, 0);
}


size_t ExtendSolidityParser::FunctionDescriptorContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionDescriptor;
}

void ExtendSolidityParser::FunctionDescriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDescriptor(this);
}

void ExtendSolidityParser::FunctionDescriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDescriptor(this);
}


std::any ExtendSolidityParser::FunctionDescriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionDescriptor(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionDescriptorContext* ExtendSolidityParser::functionDescriptor() {
  FunctionDescriptorContext *_localctx = _tracker.createInstance<FunctionDescriptorContext>(_ctx, getState());
  enterRule(_localctx, 40, ExtendSolidityParser::RuleFunctionDescriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(414);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__26: {
        enterOuterAlt(_localctx, 1);
        setState(409);
        match(ExtendSolidityParser::T__26);
        setState(411);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ExtendSolidityParser::T__12

        || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
          setState(410);
          identifier();
        }
        break;
      }

      case ExtendSolidityParser::ConstructorKeyword: {
        enterOuterAlt(_localctx, 2);
        setState(413);
        match(ExtendSolidityParser::ConstructorKeyword);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnParametersContext ------------------------------------------------------------------

ExtendSolidityParser::ReturnParametersContext::ReturnParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ParameterListContext* ExtendSolidityParser::ReturnParametersContext::parameterList() {
  return getRuleContext<ExtendSolidityParser::ParameterListContext>(0);
}


size_t ExtendSolidityParser::ReturnParametersContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleReturnParameters;
}

void ExtendSolidityParser::ReturnParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnParameters(this);
}

void ExtendSolidityParser::ReturnParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnParameters(this);
}


std::any ExtendSolidityParser::ReturnParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitReturnParameters(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ReturnParametersContext* ExtendSolidityParser::returnParameters() {
  ReturnParametersContext *_localctx = _tracker.createInstance<ReturnParametersContext>(_ctx, getState());
  enterRule(_localctx, 42, ExtendSolidityParser::RuleReturnParameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    match(ExtendSolidityParser::T__27);
    setState(417);
    parameterList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModifierListContext ------------------------------------------------------------------

ExtendSolidityParser::ModifierListContext::ModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::ModifierInvocationContext *> ExtendSolidityParser::ModifierListContext::modifierInvocation() {
  return getRuleContexts<ExtendSolidityParser::ModifierInvocationContext>();
}

ExtendSolidityParser::ModifierInvocationContext* ExtendSolidityParser::ModifierListContext::modifierInvocation(size_t i) {
  return getRuleContext<ExtendSolidityParser::ModifierInvocationContext>(i);
}

std::vector<ExtendSolidityParser::StateMutabilityContext *> ExtendSolidityParser::ModifierListContext::stateMutability() {
  return getRuleContexts<ExtendSolidityParser::StateMutabilityContext>();
}

ExtendSolidityParser::StateMutabilityContext* ExtendSolidityParser::ModifierListContext::stateMutability(size_t i) {
  return getRuleContext<ExtendSolidityParser::StateMutabilityContext>(i);
}

std::vector<ExtendSolidityParser::AccessiblityContext *> ExtendSolidityParser::ModifierListContext::accessiblity() {
  return getRuleContexts<ExtendSolidityParser::AccessiblityContext>();
}

ExtendSolidityParser::AccessiblityContext* ExtendSolidityParser::ModifierListContext::accessiblity(size_t i) {
  return getRuleContext<ExtendSolidityParser::AccessiblityContext>(i);
}

std::vector<ExtendSolidityParser::OverrideSpecifierContext *> ExtendSolidityParser::ModifierListContext::overrideSpecifier() {
  return getRuleContexts<ExtendSolidityParser::OverrideSpecifierContext>();
}

ExtendSolidityParser::OverrideSpecifierContext* ExtendSolidityParser::ModifierListContext::overrideSpecifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::OverrideSpecifierContext>(i);
}


size_t ExtendSolidityParser::ModifierListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleModifierList;
}

void ExtendSolidityParser::ModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModifierList(this);
}

void ExtendSolidityParser::ModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModifierList(this);
}


std::any ExtendSolidityParser::ModifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitModifierList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ModifierListContext* ExtendSolidityParser::modifierList() {
  ModifierListContext *_localctx = _tracker.createInstance<ModifierListContext>(_ctx, getState());
  enterRule(_localctx, 44, ExtendSolidityParser::RuleModifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(425);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || ((((_la - 110) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 110)) & 26101) != 0)) {
      setState(423);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ExtendSolidityParser::T__12:
        case ExtendSolidityParser::T__38:
        case ExtendSolidityParser::Identifier: {
          setState(419);
          modifierInvocation();
          break;
        }

        case ExtendSolidityParser::ConstantKeyword:
        case ExtendSolidityParser::PayableKeyword:
        case ExtendSolidityParser::PureKeyword:
        case ExtendSolidityParser::ViewKeyword: {
          setState(420);
          stateMutability();
          break;
        }

        case ExtendSolidityParser::ExternalKeyword:
        case ExtendSolidityParser::InternalKeyword:
        case ExtendSolidityParser::PrivateKeyword:
        case ExtendSolidityParser::PublicKeyword: {
          setState(421);
          accessiblity();
          break;
        }

        case ExtendSolidityParser::OverrideKeyword: {
          setState(422);
          overrideSpecifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(427);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OverrideSpecifierContext ------------------------------------------------------------------

ExtendSolidityParser::OverrideSpecifierContext::OverrideSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::OverrideSpecifierContext::OverrideKeyword() {
  return getToken(ExtendSolidityParser::OverrideKeyword, 0);
}


size_t ExtendSolidityParser::OverrideSpecifierContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleOverrideSpecifier;
}

void ExtendSolidityParser::OverrideSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverrideSpecifier(this);
}

void ExtendSolidityParser::OverrideSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverrideSpecifier(this);
}


std::any ExtendSolidityParser::OverrideSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitOverrideSpecifier(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::OverrideSpecifierContext* ExtendSolidityParser::overrideSpecifier() {
  OverrideSpecifierContext *_localctx = _tracker.createInstance<OverrideSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 46, ExtendSolidityParser::RuleOverrideSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    match(ExtendSolidityParser::OverrideKeyword);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessiblityContext ------------------------------------------------------------------

ExtendSolidityParser::AccessiblityContext::AccessiblityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::AccessiblityContext::ExternalKeyword() {
  return getToken(ExtendSolidityParser::ExternalKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessiblityContext::PublicKeyword() {
  return getToken(ExtendSolidityParser::PublicKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessiblityContext::InternalKeyword() {
  return getToken(ExtendSolidityParser::InternalKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessiblityContext::PrivateKeyword() {
  return getToken(ExtendSolidityParser::PrivateKeyword, 0);
}


size_t ExtendSolidityParser::AccessiblityContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAccessiblity;
}

void ExtendSolidityParser::AccessiblityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessiblity(this);
}

void ExtendSolidityParser::AccessiblityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessiblity(this);
}


std::any ExtendSolidityParser::AccessiblityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAccessiblity(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AccessiblityContext* ExtendSolidityParser::accessiblity() {
  AccessiblityContext *_localctx = _tracker.createInstance<AccessiblityContext>(_ctx, getState());
  enterRule(_localctx, 48, ExtendSolidityParser::RuleAccessiblity);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(430);
    _la = _input->LA(1);
    if (!(((((_la - 112) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 112)) & 53) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::EventDefinitionContext::EventDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::EventDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::EventParameterListContext* ExtendSolidityParser::EventDefinitionContext::eventParameterList() {
  return getRuleContext<ExtendSolidityParser::EventParameterListContext>(0);
}

ExtendSolidityParser::NatSpecContext* ExtendSolidityParser::EventDefinitionContext::natSpec() {
  return getRuleContext<ExtendSolidityParser::NatSpecContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::EventDefinitionContext::AnonymousKeyword() {
  return getToken(ExtendSolidityParser::AnonymousKeyword, 0);
}


size_t ExtendSolidityParser::EventDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEventDefinition;
}

void ExtendSolidityParser::EventDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventDefinition(this);
}

void ExtendSolidityParser::EventDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventDefinition(this);
}


std::any ExtendSolidityParser::EventDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEventDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EventDefinitionContext* ExtendSolidityParser::eventDefinition() {
  EventDefinitionContext *_localctx = _tracker.createInstance<EventDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 50, ExtendSolidityParser::RuleEventDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(433);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::NatSpecSingleLine

    || _la == ExtendSolidityParser::NatSpecMultiLine) {
      setState(432);
      natSpec();
    }
    setState(435);
    match(ExtendSolidityParser::T__28);
    setState(436);
    identifier();
    setState(437);
    eventParameterList();
    setState(439);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::AnonymousKeyword) {
      setState(438);
      match(ExtendSolidityParser::AnonymousKeyword);
    }
    setState(441);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumValueContext ------------------------------------------------------------------

ExtendSolidityParser::EnumValueContext::EnumValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::EnumValueContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::EnumValueContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEnumValue;
}

void ExtendSolidityParser::EnumValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumValue(this);
}

void ExtendSolidityParser::EnumValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumValue(this);
}


std::any ExtendSolidityParser::EnumValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEnumValue(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EnumValueContext* ExtendSolidityParser::enumValue() {
  EnumValueContext *_localctx = _tracker.createInstance<EnumValueContext>(_ctx, getState());
  enterRule(_localctx, 52, ExtendSolidityParser::RuleEnumValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::EnumDefinitionContext::EnumDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::EnumDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

std::vector<ExtendSolidityParser::EnumValueContext *> ExtendSolidityParser::EnumDefinitionContext::enumValue() {
  return getRuleContexts<ExtendSolidityParser::EnumValueContext>();
}

ExtendSolidityParser::EnumValueContext* ExtendSolidityParser::EnumDefinitionContext::enumValue(size_t i) {
  return getRuleContext<ExtendSolidityParser::EnumValueContext>(i);
}


size_t ExtendSolidityParser::EnumDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEnumDefinition;
}

void ExtendSolidityParser::EnumDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumDefinition(this);
}

void ExtendSolidityParser::EnumDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumDefinition(this);
}


std::any ExtendSolidityParser::EnumDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEnumDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EnumDefinitionContext* ExtendSolidityParser::enumDefinition() {
  EnumDefinitionContext *_localctx = _tracker.createInstance<EnumDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 54, ExtendSolidityParser::RuleEnumDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(445);
    match(ExtendSolidityParser::T__29);
    setState(446);
    identifier();
    setState(447);
    match(ExtendSolidityParser::T__13);
    setState(449);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(448);
      enumValue();
    }
    setState(455);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__14) {
      setState(451);
      match(ExtendSolidityParser::T__14);
      setState(452);
      enumValue();
      setState(457);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(458);
    match(ExtendSolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterListContext ------------------------------------------------------------------

ExtendSolidityParser::ParameterListContext::ParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::ParameterContext *> ExtendSolidityParser::ParameterListContext::parameter() {
  return getRuleContexts<ExtendSolidityParser::ParameterContext>();
}

ExtendSolidityParser::ParameterContext* ExtendSolidityParser::ParameterListContext::parameter(size_t i) {
  return getRuleContext<ExtendSolidityParser::ParameterContext>(i);
}


size_t ExtendSolidityParser::ParameterListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleParameterList;
}

void ExtendSolidityParser::ParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterList(this);
}

void ExtendSolidityParser::ParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterList(this);
}


std::any ExtendSolidityParser::ParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitParameterList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ParameterListContext* ExtendSolidityParser::parameterList() {
  ParameterListContext *_localctx = _tracker.createInstance<ParameterListContext>(_ctx, getState());
  enterRule(_localctx, 56, ExtendSolidityParser::RuleParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(460);
    match(ExtendSolidityParser::T__20);
    setState(469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(461);
      parameter();
      setState(466);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(462);
        match(ExtendSolidityParser::T__14);
        setState(463);
        parameter();
        setState(468);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(471);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

ExtendSolidityParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::ParameterContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::StorageLocationContext* ExtendSolidityParser::ParameterContext::storageLocation() {
  return getRuleContext<ExtendSolidityParser::StorageLocationContext>(0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ParameterContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::ParameterContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleParameter;
}

void ExtendSolidityParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void ExtendSolidityParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}


std::any ExtendSolidityParser::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ParameterContext* ExtendSolidityParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 58, ExtendSolidityParser::RuleParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(473);
    typeName(0);
    setState(475);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(474);
      storageLocation();
      break;
    }

    default:
      break;
    }
    setState(478);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(477);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventParameterListContext ------------------------------------------------------------------

ExtendSolidityParser::EventParameterListContext::EventParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::EventParameterContext *> ExtendSolidityParser::EventParameterListContext::eventParameter() {
  return getRuleContexts<ExtendSolidityParser::EventParameterContext>();
}

ExtendSolidityParser::EventParameterContext* ExtendSolidityParser::EventParameterListContext::eventParameter(size_t i) {
  return getRuleContext<ExtendSolidityParser::EventParameterContext>(i);
}


size_t ExtendSolidityParser::EventParameterListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEventParameterList;
}

void ExtendSolidityParser::EventParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventParameterList(this);
}

void ExtendSolidityParser::EventParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventParameterList(this);
}


std::any ExtendSolidityParser::EventParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEventParameterList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EventParameterListContext* ExtendSolidityParser::eventParameterList() {
  EventParameterListContext *_localctx = _tracker.createInstance<EventParameterListContext>(_ctx, getState());
  enterRule(_localctx, 60, ExtendSolidityParser::RuleEventParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(480);
    match(ExtendSolidityParser::T__20);
    setState(489);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(481);
      eventParameter();
      setState(486);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(482);
        match(ExtendSolidityParser::T__14);
        setState(483);
        eventParameter();
        setState(488);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(491);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventParameterContext ------------------------------------------------------------------

ExtendSolidityParser::EventParameterContext::EventParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::EventParameterContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::EventParameterContext::IndexedKeyword() {
  return getToken(ExtendSolidityParser::IndexedKeyword, 0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::EventParameterContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::EventParameterContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEventParameter;
}

void ExtendSolidityParser::EventParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventParameter(this);
}

void ExtendSolidityParser::EventParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventParameter(this);
}


std::any ExtendSolidityParser::EventParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEventParameter(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EventParameterContext* ExtendSolidityParser::eventParameter() {
  EventParameterContext *_localctx = _tracker.createInstance<EventParameterContext>(_ctx, getState());
  enterRule(_localctx, 62, ExtendSolidityParser::RuleEventParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(493);
    typeName(0);
    setState(495);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::IndexedKeyword) {
      setState(494);
      match(ExtendSolidityParser::IndexedKeyword);
    }
    setState(498);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(497);
      identifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeParameterListContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionTypeParameterListContext::FunctionTypeParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::FunctionTypeParameterContext *> ExtendSolidityParser::FunctionTypeParameterListContext::functionTypeParameter() {
  return getRuleContexts<ExtendSolidityParser::FunctionTypeParameterContext>();
}

ExtendSolidityParser::FunctionTypeParameterContext* ExtendSolidityParser::FunctionTypeParameterListContext::functionTypeParameter(size_t i) {
  return getRuleContext<ExtendSolidityParser::FunctionTypeParameterContext>(i);
}


size_t ExtendSolidityParser::FunctionTypeParameterListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionTypeParameterList;
}

void ExtendSolidityParser::FunctionTypeParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeParameterList(this);
}

void ExtendSolidityParser::FunctionTypeParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeParameterList(this);
}


std::any ExtendSolidityParser::FunctionTypeParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionTypeParameterList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionTypeParameterListContext* ExtendSolidityParser::functionTypeParameterList() {
  FunctionTypeParameterListContext *_localctx = _tracker.createInstance<FunctionTypeParameterListContext>(_ctx, getState());
  enterRule(_localctx, 64, ExtendSolidityParser::RuleFunctionTypeParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(500);
    match(ExtendSolidityParser::T__20);
    setState(509);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(501);
      functionTypeParameter();
      setState(506);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(502);
        match(ExtendSolidityParser::T__14);
        setState(503);
        functionTypeParameter();
        setState(508);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(511);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeParameterContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionTypeParameterContext::FunctionTypeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::FunctionTypeParameterContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::StorageLocationContext* ExtendSolidityParser::FunctionTypeParameterContext::storageLocation() {
  return getRuleContext<ExtendSolidityParser::StorageLocationContext>(0);
}


size_t ExtendSolidityParser::FunctionTypeParameterContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionTypeParameter;
}

void ExtendSolidityParser::FunctionTypeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeParameter(this);
}

void ExtendSolidityParser::FunctionTypeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeParameter(this);
}


std::any ExtendSolidityParser::FunctionTypeParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionTypeParameter(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionTypeParameterContext* ExtendSolidityParser::functionTypeParameter() {
  FunctionTypeParameterContext *_localctx = _tracker.createInstance<FunctionTypeParameterContext>(_ctx, getState());
  enterRule(_localctx, 66, ExtendSolidityParser::RuleFunctionTypeParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    typeName(0);
    setState(515);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 962072674304) != 0)) {
      setState(514);
      storageLocation();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::VariableDeclarationContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::VariableDeclarationContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::StorageLocationContext* ExtendSolidityParser::VariableDeclarationContext::storageLocation() {
  return getRuleContext<ExtendSolidityParser::StorageLocationContext>(0);
}


size_t ExtendSolidityParser::VariableDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVariableDeclaration;
}

void ExtendSolidityParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void ExtendSolidityParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}


std::any ExtendSolidityParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VariableDeclarationContext* ExtendSolidityParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 68, ExtendSolidityParser::RuleVariableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(517);
    typeName(0);
    setState(519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      setState(518);
      storageLocation();
      break;
    }

    default:
      break;
    }
    setState(521);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext ------------------------------------------------------------------

ExtendSolidityParser::TypeNameContext::TypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ElementaryTypeNameContext* ExtendSolidityParser::TypeNameContext::elementaryTypeName() {
  return getRuleContext<ExtendSolidityParser::ElementaryTypeNameContext>(0);
}

ExtendSolidityParser::UserDefinedTypeNameContext* ExtendSolidityParser::TypeNameContext::userDefinedTypeName() {
  return getRuleContext<ExtendSolidityParser::UserDefinedTypeNameContext>(0);
}

ExtendSolidityParser::MappingContext* ExtendSolidityParser::TypeNameContext::mapping() {
  return getRuleContext<ExtendSolidityParser::MappingContext>(0);
}

ExtendSolidityParser::FunctionTypeNameContext* ExtendSolidityParser::TypeNameContext::functionTypeName() {
  return getRuleContext<ExtendSolidityParser::FunctionTypeNameContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::TypeNameContext::PayableKeyword() {
  return getToken(ExtendSolidityParser::PayableKeyword, 0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::TypeNameContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::TypeNameContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::TypeNameContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleTypeName;
}

void ExtendSolidityParser::TypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeName(this);
}

void ExtendSolidityParser::TypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeName(this);
}


std::any ExtendSolidityParser::TypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitTypeName(this);
  else
    return visitor->visitChildren(this);
}


ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::typeName() {
   return typeName(0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::typeName(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ExtendSolidityParser::TypeNameContext *_localctx = _tracker.createInstance<TypeNameContext>(_ctx, parentState);
  ExtendSolidityParser::TypeNameContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 70;
  enterRecursionRule(_localctx, 70, ExtendSolidityParser::RuleTypeName, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(524);
      elementaryTypeName();
      break;
    }

    case 2: {
      setState(525);
      userDefinedTypeName();
      break;
    }

    case 3: {
      setState(526);
      mapping();
      break;
    }

    case 4: {
      setState(527);
      functionTypeName();
      break;
    }

    case 5: {
      setState(528);
      match(ExtendSolidityParser::T__32);
      setState(529);
      match(ExtendSolidityParser::PayableKeyword);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(540);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<TypeNameContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleTypeName);
        setState(532);

        if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
        setState(533);
        match(ExtendSolidityParser::T__30);
        setState(535);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
          setState(534);
          expression(0);
        }
        setState(537);
        match(ExtendSolidityParser::T__31); 
      }
      setState(542);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UserDefinedTypeNameContext ------------------------------------------------------------------

ExtendSolidityParser::UserDefinedTypeNameContext::UserDefinedTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::IdentifierContext *> ExtendSolidityParser::UserDefinedTypeNameContext::identifier() {
  return getRuleContexts<ExtendSolidityParser::IdentifierContext>();
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::UserDefinedTypeNameContext::identifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(i);
}


size_t ExtendSolidityParser::UserDefinedTypeNameContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleUserDefinedTypeName;
}

void ExtendSolidityParser::UserDefinedTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserDefinedTypeName(this);
}

void ExtendSolidityParser::UserDefinedTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserDefinedTypeName(this);
}


std::any ExtendSolidityParser::UserDefinedTypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitUserDefinedTypeName(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::UserDefinedTypeNameContext* ExtendSolidityParser::userDefinedTypeName() {
  UserDefinedTypeNameContext *_localctx = _tracker.createInstance<UserDefinedTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 72, ExtendSolidityParser::RuleUserDefinedTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(543);
    identifier();
    setState(548);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(544);
        match(ExtendSolidityParser::T__33);
        setState(545);
        identifier(); 
      }
      setState(550);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MappingContext ------------------------------------------------------------------

ExtendSolidityParser::MappingContext::MappingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ElementaryTypeNameContext* ExtendSolidityParser::MappingContext::elementaryTypeName() {
  return getRuleContext<ExtendSolidityParser::ElementaryTypeNameContext>(0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::MappingContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}


size_t ExtendSolidityParser::MappingContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMapping;
}

void ExtendSolidityParser::MappingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapping(this);
}

void ExtendSolidityParser::MappingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapping(this);
}


std::any ExtendSolidityParser::MappingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMapping(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MappingContext* ExtendSolidityParser::mapping() {
  MappingContext *_localctx = _tracker.createInstance<MappingContext>(_ctx, getState());
  enterRule(_localctx, 74, ExtendSolidityParser::RuleMapping);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(551);
    match(ExtendSolidityParser::T__34);
    setState(552);
    match(ExtendSolidityParser::T__20);
    setState(553);
    elementaryTypeName();
    setState(554);
    match(ExtendSolidityParser::T__35);
    setState(555);
    typeName(0);
    setState(556);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeNameContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionTypeNameContext::FunctionTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::FunctionTypeParameterListContext *> ExtendSolidityParser::FunctionTypeNameContext::functionTypeParameterList() {
  return getRuleContexts<ExtendSolidityParser::FunctionTypeParameterListContext>();
}

ExtendSolidityParser::FunctionTypeParameterListContext* ExtendSolidityParser::FunctionTypeNameContext::functionTypeParameterList(size_t i) {
  return getRuleContext<ExtendSolidityParser::FunctionTypeParameterListContext>(i);
}

std::vector<tree::TerminalNode *> ExtendSolidityParser::FunctionTypeNameContext::InternalKeyword() {
  return getTokens(ExtendSolidityParser::InternalKeyword);
}

tree::TerminalNode* ExtendSolidityParser::FunctionTypeNameContext::InternalKeyword(size_t i) {
  return getToken(ExtendSolidityParser::InternalKeyword, i);
}

std::vector<tree::TerminalNode *> ExtendSolidityParser::FunctionTypeNameContext::ExternalKeyword() {
  return getTokens(ExtendSolidityParser::ExternalKeyword);
}

tree::TerminalNode* ExtendSolidityParser::FunctionTypeNameContext::ExternalKeyword(size_t i) {
  return getToken(ExtendSolidityParser::ExternalKeyword, i);
}

std::vector<ExtendSolidityParser::StateMutabilityContext *> ExtendSolidityParser::FunctionTypeNameContext::stateMutability() {
  return getRuleContexts<ExtendSolidityParser::StateMutabilityContext>();
}

ExtendSolidityParser::StateMutabilityContext* ExtendSolidityParser::FunctionTypeNameContext::stateMutability(size_t i) {
  return getRuleContext<ExtendSolidityParser::StateMutabilityContext>(i);
}


size_t ExtendSolidityParser::FunctionTypeNameContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionTypeName;
}

void ExtendSolidityParser::FunctionTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTypeName(this);
}

void ExtendSolidityParser::FunctionTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTypeName(this);
}


std::any ExtendSolidityParser::FunctionTypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionTypeName(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionTypeNameContext* ExtendSolidityParser::functionTypeName() {
  FunctionTypeNameContext *_localctx = _tracker.createInstance<FunctionTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 76, ExtendSolidityParser::RuleFunctionTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(558);
    match(ExtendSolidityParser::T__26);
    setState(559);
    functionTypeParameterList();
    setState(565);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(563);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ExtendSolidityParser::InternalKeyword: {
            setState(560);
            match(ExtendSolidityParser::InternalKeyword);
            break;
          }

          case ExtendSolidityParser::ExternalKeyword: {
            setState(561);
            match(ExtendSolidityParser::ExternalKeyword);
            break;
          }

          case ExtendSolidityParser::ConstantKeyword:
          case ExtendSolidityParser::PayableKeyword:
          case ExtendSolidityParser::PureKeyword:
          case ExtendSolidityParser::ViewKeyword: {
            setState(562);
            stateMutability();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(567);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    }
    setState(570);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(568);
      match(ExtendSolidityParser::T__27);
      setState(569);
      functionTypeParameterList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageLocationContext ------------------------------------------------------------------

ExtendSolidityParser::StorageLocationContext::StorageLocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::StorageLocationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleStorageLocation;
}

void ExtendSolidityParser::StorageLocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageLocation(this);
}

void ExtendSolidityParser::StorageLocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageLocation(this);
}


std::any ExtendSolidityParser::StorageLocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitStorageLocation(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::StorageLocationContext* ExtendSolidityParser::storageLocation() {
  StorageLocationContext *_localctx = _tracker.createInstance<StorageLocationContext>(_ctx, getState());
  enterRule(_localctx, 78, ExtendSolidityParser::RuleStorageLocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 962072674304) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StateMutabilityContext ------------------------------------------------------------------

ExtendSolidityParser::StateMutabilityContext::StateMutabilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::StateMutabilityContext::PureKeyword() {
  return getToken(ExtendSolidityParser::PureKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::StateMutabilityContext::ConstantKeyword() {
  return getToken(ExtendSolidityParser::ConstantKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::StateMutabilityContext::ViewKeyword() {
  return getToken(ExtendSolidityParser::ViewKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::StateMutabilityContext::PayableKeyword() {
  return getToken(ExtendSolidityParser::PayableKeyword, 0);
}


size_t ExtendSolidityParser::StateMutabilityContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleStateMutability;
}

void ExtendSolidityParser::StateMutabilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStateMutability(this);
}

void ExtendSolidityParser::StateMutabilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStateMutability(this);
}


std::any ExtendSolidityParser::StateMutabilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitStateMutability(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::StateMutabilityContext* ExtendSolidityParser::stateMutability() {
  StateMutabilityContext *_localctx = _tracker.createInstance<StateMutabilityContext>(_ctx, getState());
  enterRule(_localctx, 80, ExtendSolidityParser::RuleStateMutability);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(574);
    _la = _input->LA(1);
    if (!(((((_la - 110) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 110)) & 1313) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

ExtendSolidityParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::StatementContext *> ExtendSolidityParser::BlockContext::statement() {
  return getRuleContexts<ExtendSolidityParser::StatementContext>();
}

ExtendSolidityParser::StatementContext* ExtendSolidityParser::BlockContext::statement(size_t i) {
  return getRuleContext<ExtendSolidityParser::StatementContext>(i);
}


size_t ExtendSolidityParser::BlockContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleBlock;
}

void ExtendSolidityParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void ExtendSolidityParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}


std::any ExtendSolidityParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 82, ExtendSolidityParser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    match(ExtendSolidityParser::T__13);
    setState(580);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220116135316529136) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3639091009255636993) != 0)) {
      setState(577);
      statement();
      setState(582);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(583);
    match(ExtendSolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

ExtendSolidityParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IfStatementContext* ExtendSolidityParser::StatementContext::ifStatement() {
  return getRuleContext<ExtendSolidityParser::IfStatementContext>(0);
}

ExtendSolidityParser::WhileStatementContext* ExtendSolidityParser::StatementContext::whileStatement() {
  return getRuleContext<ExtendSolidityParser::WhileStatementContext>(0);
}

ExtendSolidityParser::ForStatementContext* ExtendSolidityParser::StatementContext::forStatement() {
  return getRuleContext<ExtendSolidityParser::ForStatementContext>(0);
}

ExtendSolidityParser::InlineAssemblyStatementContext* ExtendSolidityParser::StatementContext::inlineAssemblyStatement() {
  return getRuleContext<ExtendSolidityParser::InlineAssemblyStatementContext>(0);
}

ExtendSolidityParser::DoWhileStatementContext* ExtendSolidityParser::StatementContext::doWhileStatement() {
  return getRuleContext<ExtendSolidityParser::DoWhileStatementContext>(0);
}

ExtendSolidityParser::ContinueStatementContext* ExtendSolidityParser::StatementContext::continueStatement() {
  return getRuleContext<ExtendSolidityParser::ContinueStatementContext>(0);
}

ExtendSolidityParser::BreakStatementContext* ExtendSolidityParser::StatementContext::breakStatement() {
  return getRuleContext<ExtendSolidityParser::BreakStatementContext>(0);
}

ExtendSolidityParser::ReturnStatementContext* ExtendSolidityParser::StatementContext::returnStatement() {
  return getRuleContext<ExtendSolidityParser::ReturnStatementContext>(0);
}

ExtendSolidityParser::ThrowStatementContext* ExtendSolidityParser::StatementContext::throwStatement() {
  return getRuleContext<ExtendSolidityParser::ThrowStatementContext>(0);
}

ExtendSolidityParser::EmitStatementContext* ExtendSolidityParser::StatementContext::emitStatement() {
  return getRuleContext<ExtendSolidityParser::EmitStatementContext>(0);
}

ExtendSolidityParser::RelayStatementContext* ExtendSolidityParser::StatementContext::relayStatement() {
  return getRuleContext<ExtendSolidityParser::RelayStatementContext>(0);
}

ExtendSolidityParser::VariableDeclarationStatementContext* ExtendSolidityParser::StatementContext::variableDeclarationStatement() {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationStatementContext>(0);
}

ExtendSolidityParser::ExpressionStatementContext* ExtendSolidityParser::StatementContext::expressionStatement() {
  return getRuleContext<ExtendSolidityParser::ExpressionStatementContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::StatementContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}


size_t ExtendSolidityParser::StatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleStatement;
}

void ExtendSolidityParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void ExtendSolidityParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}


std::any ExtendSolidityParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::StatementContext* ExtendSolidityParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 84, ExtendSolidityParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(585);
      ifStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(586);
      whileStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(587);
      forStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(588);
      inlineAssemblyStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(589);
      doWhileStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(590);
      continueStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(591);
      breakStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(592);
      returnStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(593);
      throwStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(594);
      emitStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(595);
      relayStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(596);
      variableDeclarationStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(597);
      expressionStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(598);
      block();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

ExtendSolidityParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ExpressionStatementContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::ExpressionStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleExpressionStatement;
}

void ExtendSolidityParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void ExtendSolidityParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}


std::any ExtendSolidityParser::ExpressionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitExpressionStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ExpressionStatementContext* ExtendSolidityParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, ExtendSolidityParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    expression(0);
    setState(602);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

ExtendSolidityParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IfWithBlockContext* ExtendSolidityParser::IfStatementContext::ifWithBlock() {
  return getRuleContext<ExtendSolidityParser::IfWithBlockContext>(0);
}

std::vector<ExtendSolidityParser::ElseIfWithBlockContext *> ExtendSolidityParser::IfStatementContext::elseIfWithBlock() {
  return getRuleContexts<ExtendSolidityParser::ElseIfWithBlockContext>();
}

ExtendSolidityParser::ElseIfWithBlockContext* ExtendSolidityParser::IfStatementContext::elseIfWithBlock(size_t i) {
  return getRuleContext<ExtendSolidityParser::ElseIfWithBlockContext>(i);
}

ExtendSolidityParser::ElseWithBlockContext* ExtendSolidityParser::IfStatementContext::elseWithBlock() {
  return getRuleContext<ExtendSolidityParser::ElseWithBlockContext>(0);
}


size_t ExtendSolidityParser::IfStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleIfStatement;
}

void ExtendSolidityParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void ExtendSolidityParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}


std::any ExtendSolidityParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::IfStatementContext* ExtendSolidityParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 88, ExtendSolidityParser::RuleIfStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(604);
    ifWithBlock();
    setState(608);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(605);
        elseIfWithBlock(); 
      }
      setState(610);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
    setState(612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__40) {
      setState(611);
      elseWithBlock();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfWithBlockContext ------------------------------------------------------------------

ExtendSolidityParser::IfWithBlockContext::IfWithBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::IfWithBlockContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::IfWithBlockContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}


size_t ExtendSolidityParser::IfWithBlockContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleIfWithBlock;
}

void ExtendSolidityParser::IfWithBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfWithBlock(this);
}

void ExtendSolidityParser::IfWithBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfWithBlock(this);
}


std::any ExtendSolidityParser::IfWithBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitIfWithBlock(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::IfWithBlockContext* ExtendSolidityParser::ifWithBlock() {
  IfWithBlockContext *_localctx = _tracker.createInstance<IfWithBlockContext>(_ctx, getState());
  enterRule(_localctx, 90, ExtendSolidityParser::RuleIfWithBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    match(ExtendSolidityParser::T__39);
    setState(615);
    match(ExtendSolidityParser::T__20);
    setState(616);
    expression(0);
    setState(617);
    match(ExtendSolidityParser::T__21);
    setState(618);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseWithBlockContext ------------------------------------------------------------------

ExtendSolidityParser::ElseWithBlockContext::ElseWithBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::ElseWithBlockContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}


size_t ExtendSolidityParser::ElseWithBlockContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleElseWithBlock;
}

void ExtendSolidityParser::ElseWithBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseWithBlock(this);
}

void ExtendSolidityParser::ElseWithBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseWithBlock(this);
}


std::any ExtendSolidityParser::ElseWithBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitElseWithBlock(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ElseWithBlockContext* ExtendSolidityParser::elseWithBlock() {
  ElseWithBlockContext *_localctx = _tracker.createInstance<ElseWithBlockContext>(_ctx, getState());
  enterRule(_localctx, 92, ExtendSolidityParser::RuleElseWithBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(620);
    match(ExtendSolidityParser::T__40);
    setState(621);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseIfWithBlockContext ------------------------------------------------------------------

ExtendSolidityParser::ElseIfWithBlockContext::ElseIfWithBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ElseIfWithBlockContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::ElseIfWithBlockContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}


size_t ExtendSolidityParser::ElseIfWithBlockContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleElseIfWithBlock;
}

void ExtendSolidityParser::ElseIfWithBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseIfWithBlock(this);
}

void ExtendSolidityParser::ElseIfWithBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseIfWithBlock(this);
}


std::any ExtendSolidityParser::ElseIfWithBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitElseIfWithBlock(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ElseIfWithBlockContext* ExtendSolidityParser::elseIfWithBlock() {
  ElseIfWithBlockContext *_localctx = _tracker.createInstance<ElseIfWithBlockContext>(_ctx, getState());
  enterRule(_localctx, 94, ExtendSolidityParser::RuleElseIfWithBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(623);
    match(ExtendSolidityParser::T__40);
    setState(624);
    match(ExtendSolidityParser::T__39);
    setState(625);
    match(ExtendSolidityParser::T__20);
    setState(626);
    expression(0);
    setState(627);
    match(ExtendSolidityParser::T__21);
    setState(628);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

ExtendSolidityParser::WhileStatementContext::WhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::WhileStatementContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

ExtendSolidityParser::StatementContext* ExtendSolidityParser::WhileStatementContext::statement() {
  return getRuleContext<ExtendSolidityParser::StatementContext>(0);
}


size_t ExtendSolidityParser::WhileStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleWhileStatement;
}

void ExtendSolidityParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}

void ExtendSolidityParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}


std::any ExtendSolidityParser::WhileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitWhileStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::WhileStatementContext* ExtendSolidityParser::whileStatement() {
  WhileStatementContext *_localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 96, ExtendSolidityParser::RuleWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(630);
    match(ExtendSolidityParser::T__41);
    setState(631);
    match(ExtendSolidityParser::T__20);
    setState(632);
    expression(0);
    setState(633);
    match(ExtendSolidityParser::T__21);
    setState(634);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStatementContext ------------------------------------------------------------------

ExtendSolidityParser::ForStatementContext::ForStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::ForStatementContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}

ExtendSolidityParser::LocalVariableDeclarationContext* ExtendSolidityParser::ForStatementContext::localVariableDeclaration() {
  return getRuleContext<ExtendSolidityParser::LocalVariableDeclarationContext>(0);
}

std::vector<ExtendSolidityParser::ExpressionContext *> ExtendSolidityParser::ForStatementContext::expression() {
  return getRuleContexts<ExtendSolidityParser::ExpressionContext>();
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ForStatementContext::expression(size_t i) {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(i);
}


size_t ExtendSolidityParser::ForStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleForStatement;
}

void ExtendSolidityParser::ForStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForStatement(this);
}

void ExtendSolidityParser::ForStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForStatement(this);
}


std::any ExtendSolidityParser::ForStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitForStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ForStatementContext* ExtendSolidityParser::forStatement() {
  ForStatementContext *_localctx = _tracker.createInstance<ForStatementContext>(_ctx, getState());
  enterRule(_localctx, 98, ExtendSolidityParser::RuleForStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(636);
    match(ExtendSolidityParser::T__23);
    setState(637);
    match(ExtendSolidityParser::T__20);
    setState(640);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
    case 1: {
      setState(638);
      localVariableDeclaration();
      break;
    }

    case 2: {
      setState(639);
      antlrcpp::downCast<ForStatementContext *>(_localctx)->firstExpression = expression(0);
      break;
    }

    default:
      break;
    }
    setState(642);
    match(ExtendSolidityParser::T__1);
    setState(644);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(643);
      antlrcpp::downCast<ForStatementContext *>(_localctx)->secondExpression = expression(0);
    }
    setState(646);
    match(ExtendSolidityParser::T__1);
    setState(648);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(647);
      antlrcpp::downCast<ForStatementContext *>(_localctx)->thirdExpression = expression(0);
    }
    setState(650);
    match(ExtendSolidityParser::T__21);
    setState(651);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InlineAssemblyStatementContext ------------------------------------------------------------------

ExtendSolidityParser::InlineAssemblyStatementContext::InlineAssemblyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::InlineAssemblyStatementContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::InlineAssemblyStatementContext::StringLiteral() {
  return getToken(ExtendSolidityParser::StringLiteral, 0);
}


size_t ExtendSolidityParser::InlineAssemblyStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleInlineAssemblyStatement;
}

void ExtendSolidityParser::InlineAssemblyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInlineAssemblyStatement(this);
}

void ExtendSolidityParser::InlineAssemblyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInlineAssemblyStatement(this);
}


std::any ExtendSolidityParser::InlineAssemblyStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitInlineAssemblyStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::InlineAssemblyStatementContext* ExtendSolidityParser::inlineAssemblyStatement() {
  InlineAssemblyStatementContext *_localctx = _tracker.createInstance<InlineAssemblyStatementContext>(_ctx, getState());
  enterRule(_localctx, 100, ExtendSolidityParser::RuleInlineAssemblyStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    match(ExtendSolidityParser::T__42);
    setState(655);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::StringLiteral) {
      setState(654);
      match(ExtendSolidityParser::StringLiteral);
    }
    setState(657);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoWhileStatementContext ------------------------------------------------------------------

ExtendSolidityParser::DoWhileStatementContext::DoWhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::StatementContext* ExtendSolidityParser::DoWhileStatementContext::statement() {
  return getRuleContext<ExtendSolidityParser::StatementContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::DoWhileStatementContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::DoWhileStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleDoWhileStatement;
}

void ExtendSolidityParser::DoWhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoWhileStatement(this);
}

void ExtendSolidityParser::DoWhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoWhileStatement(this);
}


std::any ExtendSolidityParser::DoWhileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitDoWhileStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::DoWhileStatementContext* ExtendSolidityParser::doWhileStatement() {
  DoWhileStatementContext *_localctx = _tracker.createInstance<DoWhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 102, ExtendSolidityParser::RuleDoWhileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(ExtendSolidityParser::T__43);
    setState(660);
    statement();
    setState(661);
    match(ExtendSolidityParser::T__41);
    setState(662);
    match(ExtendSolidityParser::T__20);
    setState(663);
    expression(0);
    setState(664);
    match(ExtendSolidityParser::T__21);
    setState(665);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStatementContext ------------------------------------------------------------------

ExtendSolidityParser::ContinueStatementContext::ContinueStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::ContinueStatementContext::ContinueKeyword() {
  return getToken(ExtendSolidityParser::ContinueKeyword, 0);
}


size_t ExtendSolidityParser::ContinueStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleContinueStatement;
}

void ExtendSolidityParser::ContinueStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinueStatement(this);
}

void ExtendSolidityParser::ContinueStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinueStatement(this);
}


std::any ExtendSolidityParser::ContinueStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitContinueStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ContinueStatementContext* ExtendSolidityParser::continueStatement() {
  ContinueStatementContext *_localctx = _tracker.createInstance<ContinueStatementContext>(_ctx, getState());
  enterRule(_localctx, 104, ExtendSolidityParser::RuleContinueStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(667);
    match(ExtendSolidityParser::ContinueKeyword);
    setState(668);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStatementContext ------------------------------------------------------------------

ExtendSolidityParser::BreakStatementContext::BreakStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::BreakStatementContext::BreakKeyword() {
  return getToken(ExtendSolidityParser::BreakKeyword, 0);
}


size_t ExtendSolidityParser::BreakStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleBreakStatement;
}

void ExtendSolidityParser::BreakStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreakStatement(this);
}

void ExtendSolidityParser::BreakStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreakStatement(this);
}


std::any ExtendSolidityParser::BreakStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitBreakStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::BreakStatementContext* ExtendSolidityParser::breakStatement() {
  BreakStatementContext *_localctx = _tracker.createInstance<BreakStatementContext>(_ctx, getState());
  enterRule(_localctx, 106, ExtendSolidityParser::RuleBreakStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(670);
    match(ExtendSolidityParser::BreakKeyword);
    setState(671);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

ExtendSolidityParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ReturnStatementContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::ReturnStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleReturnStatement;
}

void ExtendSolidityParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void ExtendSolidityParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}


std::any ExtendSolidityParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ReturnStatementContext* ExtendSolidityParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 108, ExtendSolidityParser::RuleReturnStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(673);
    match(ExtendSolidityParser::T__44);
    setState(675);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(674);
      expression(0);
    }
    setState(677);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowStatementContext ------------------------------------------------------------------

ExtendSolidityParser::ThrowStatementContext::ThrowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::ThrowStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleThrowStatement;
}

void ExtendSolidityParser::ThrowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowStatement(this);
}

void ExtendSolidityParser::ThrowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowStatement(this);
}


std::any ExtendSolidityParser::ThrowStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitThrowStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ThrowStatementContext* ExtendSolidityParser::throwStatement() {
  ThrowStatementContext *_localctx = _tracker.createInstance<ThrowStatementContext>(_ctx, getState());
  enterRule(_localctx, 110, ExtendSolidityParser::RuleThrowStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(679);
    match(ExtendSolidityParser::T__45);
    setState(680);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmitStatementContext ------------------------------------------------------------------

ExtendSolidityParser::EmitStatementContext::EmitStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::FunctionCallContext* ExtendSolidityParser::EmitStatementContext::functionCall() {
  return getRuleContext<ExtendSolidityParser::FunctionCallContext>(0);
}


size_t ExtendSolidityParser::EmitStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleEmitStatement;
}

void ExtendSolidityParser::EmitStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmitStatement(this);
}

void ExtendSolidityParser::EmitStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmitStatement(this);
}


std::any ExtendSolidityParser::EmitStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitEmitStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::EmitStatementContext* ExtendSolidityParser::emitStatement() {
  EmitStatementContext *_localctx = _tracker.createInstance<EmitStatementContext>(_ctx, getState());
  enterRule(_localctx, 112, ExtendSolidityParser::RuleEmitStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(682);
    match(ExtendSolidityParser::T__46);
    setState(683);
    functionCall();
    setState(684);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelayStatementContext ------------------------------------------------------------------

ExtendSolidityParser::RelayStatementContext::RelayStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::RelayStatementContext::RelayKeyword() {
  return getToken(ExtendSolidityParser::RelayKeyword, 0);
}

ExtendSolidityParser::RelayScopeContext* ExtendSolidityParser::RelayStatementContext::relayScope() {
  return getRuleContext<ExtendSolidityParser::RelayScopeContext>(0);
}

ExtendSolidityParser::RelayLambdaDefinitionContext* ExtendSolidityParser::RelayStatementContext::relayLambdaDefinition() {
  return getRuleContext<ExtendSolidityParser::RelayLambdaDefinitionContext>(0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::RelayStatementContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::FunctionCallArgumentsContext* ExtendSolidityParser::RelayStatementContext::functionCallArguments() {
  return getRuleContext<ExtendSolidityParser::FunctionCallArgumentsContext>(0);
}


size_t ExtendSolidityParser::RelayStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleRelayStatement;
}

void ExtendSolidityParser::RelayStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelayStatement(this);
}

void ExtendSolidityParser::RelayStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelayStatement(this);
}


std::any ExtendSolidityParser::RelayStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitRelayStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::RelayStatementContext* ExtendSolidityParser::relayStatement() {
  RelayStatementContext *_localctx = _tracker.createInstance<RelayStatementContext>(_ctx, getState());
  enterRule(_localctx, 114, ExtendSolidityParser::RuleRelayStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(686);
    match(ExtendSolidityParser::RelayKeyword);
    setState(687);
    relayScope();
    setState(695);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::Identifier: {
        setState(688);
        identifier();
        setState(689);
        match(ExtendSolidityParser::T__20);
        setState(690);
        functionCallArguments();
        setState(691);
        match(ExtendSolidityParser::T__21);
        setState(692);
        match(ExtendSolidityParser::T__1);
        break;
      }

      case ExtendSolidityParser::T__20: {
        setState(694);
        relayLambdaDefinition();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelayLambdaDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::RelayLambdaDefinitionContext::RelayLambdaDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::BlockContext* ExtendSolidityParser::RelayLambdaDefinitionContext::block() {
  return getRuleContext<ExtendSolidityParser::BlockContext>(0);
}

std::vector<ExtendSolidityParser::RelayLambdaParameterContext *> ExtendSolidityParser::RelayLambdaDefinitionContext::relayLambdaParameter() {
  return getRuleContexts<ExtendSolidityParser::RelayLambdaParameterContext>();
}

ExtendSolidityParser::RelayLambdaParameterContext* ExtendSolidityParser::RelayLambdaDefinitionContext::relayLambdaParameter(size_t i) {
  return getRuleContext<ExtendSolidityParser::RelayLambdaParameterContext>(i);
}


size_t ExtendSolidityParser::RelayLambdaDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleRelayLambdaDefinition;
}

void ExtendSolidityParser::RelayLambdaDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelayLambdaDefinition(this);
}

void ExtendSolidityParser::RelayLambdaDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelayLambdaDefinition(this);
}


std::any ExtendSolidityParser::RelayLambdaDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitRelayLambdaDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::RelayLambdaDefinitionContext* ExtendSolidityParser::relayLambdaDefinition() {
  RelayLambdaDefinitionContext *_localctx = _tracker.createInstance<RelayLambdaDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 116, ExtendSolidityParser::RuleRelayLambdaDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(ExtendSolidityParser::T__20);
    setState(706);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016904) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(698);
      relayLambdaParameter();
      setState(703);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(699);
        match(ExtendSolidityParser::T__14);
        setState(700);
        relayLambdaParameter();
        setState(705);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(708);
    match(ExtendSolidityParser::T__21);
    setState(709);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelayLambdaParameterContext ------------------------------------------------------------------

ExtendSolidityParser::RelayLambdaParameterContext::RelayLambdaParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::RelayLambdaParameterContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::RelayLambdaParameterContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::RelayLambdaParameterContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}


size_t ExtendSolidityParser::RelayLambdaParameterContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleRelayLambdaParameter;
}

void ExtendSolidityParser::RelayLambdaParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelayLambdaParameter(this);
}

void ExtendSolidityParser::RelayLambdaParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelayLambdaParameter(this);
}


std::any ExtendSolidityParser::RelayLambdaParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitRelayLambdaParameter(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::RelayLambdaParameterContext* ExtendSolidityParser::relayLambdaParameter() {
  RelayLambdaParameterContext *_localctx = _tracker.createInstance<RelayLambdaParameterContext>(_ctx, getState());
  enterRule(_localctx, 118, ExtendSolidityParser::RuleRelayLambdaParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(721);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__26:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__34:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__47:
      case ExtendSolidityParser::T__51:
      case ExtendSolidityParser::T__52:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::Int:
      case ExtendSolidityParser::Uint:
      case ExtendSolidityParser::Byte:
      case ExtendSolidityParser::Fixed:
      case ExtendSolidityParser::Ufixed:
      case ExtendSolidityParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(713);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
        case 1: {
          setState(711);
          match(ExtendSolidityParser::T__47);
          break;
        }

        case 2: {
          setState(712);
          typeName(0);
          break;
        }

        default:
          break;
        }
        setState(715);
        identifier();
        setState(716);
        match(ExtendSolidityParser::T__8);
        setState(717);
        expression(0);
        break;
      }

      case ExtendSolidityParser::T__2: {
        enterOuterAlt(_localctx, 2);
        setState(719);
        match(ExtendSolidityParser::T__2);
        setState(720);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelayScopeContext ------------------------------------------------------------------

ExtendSolidityParser::RelayScopeContext::RelayScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::RelayScopeContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::RelayScopeContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleRelayScope;
}

void ExtendSolidityParser::RelayScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelayScope(this);
}

void ExtendSolidityParser::RelayScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelayScope(this);
}


std::any ExtendSolidityParser::RelayScopeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitRelayScope(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::RelayScopeContext* ExtendSolidityParser::relayScope() {
  RelayScopeContext *_localctx = _tracker.createInstance<RelayScopeContext>(_ctx, getState());
  enterRule(_localctx, 120, ExtendSolidityParser::RuleRelayScope);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(723);
    match(ExtendSolidityParser::T__48);
    setState(727);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__49: {
        setState(724);
        match(ExtendSolidityParser::T__49);
        break;
      }

      case ExtendSolidityParser::T__50: {
        setState(725);
        match(ExtendSolidityParser::T__50);
        break;
      }

      case ExtendSolidityParser::T__3:
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__20:
      case ExtendSolidityParser::T__30:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__47:
      case ExtendSolidityParser::T__51:
      case ExtendSolidityParser::T__52:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::T__54:
      case ExtendSolidityParser::T__57:
      case ExtendSolidityParser::T__58:
      case ExtendSolidityParser::T__59:
      case ExtendSolidityParser::T__60:
      case ExtendSolidityParser::T__61:
      case ExtendSolidityParser::T__62:
      case ExtendSolidityParser::T__63:
      case ExtendSolidityParser::BooleanLiteral:
      case ExtendSolidityParser::DecimalNumber:
      case ExtendSolidityParser::HexNumber:
      case ExtendSolidityParser::Int:
      case ExtendSolidityParser::Uint:
      case ExtendSolidityParser::Byte:
      case ExtendSolidityParser::Fixed:
      case ExtendSolidityParser::Ufixed:
      case ExtendSolidityParser::HexLiteral:
      case ExtendSolidityParser::TypeKeyword:
      case ExtendSolidityParser::Identifier:
      case ExtendSolidityParser::StringLiteral: {
        setState(726);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationStatementContext ------------------------------------------------------------------

ExtendSolidityParser::VariableDeclarationStatementContext::VariableDeclarationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::LocalVariableDeclarationContext* ExtendSolidityParser::VariableDeclarationStatementContext::localVariableDeclaration() {
  return getRuleContext<ExtendSolidityParser::LocalVariableDeclarationContext>(0);
}


size_t ExtendSolidityParser::VariableDeclarationStatementContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVariableDeclarationStatement;
}

void ExtendSolidityParser::VariableDeclarationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationStatement(this);
}

void ExtendSolidityParser::VariableDeclarationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationStatement(this);
}


std::any ExtendSolidityParser::VariableDeclarationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVariableDeclarationStatement(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VariableDeclarationStatementContext* ExtendSolidityParser::variableDeclarationStatement() {
  VariableDeclarationStatementContext *_localctx = _tracker.createInstance<VariableDeclarationStatementContext>(_ctx, getState());
  enterRule(_localctx, 122, ExtendSolidityParser::RuleVariableDeclarationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(729);
    localVariableDeclaration();
    setState(730);
    match(ExtendSolidityParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocalVariableDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::LocalVariableDeclarationContext::LocalVariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierListContext* ExtendSolidityParser::LocalVariableDeclarationContext::identifierList() {
  return getRuleContext<ExtendSolidityParser::IdentifierListContext>(0);
}

ExtendSolidityParser::VariableDeclarationContext* ExtendSolidityParser::LocalVariableDeclarationContext::variableDeclaration() {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationContext>(0);
}

ExtendSolidityParser::VariableDeclarationListContext* ExtendSolidityParser::LocalVariableDeclarationContext::variableDeclarationList() {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationListContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::LocalVariableDeclarationContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::LocalVariableDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleLocalVariableDeclaration;
}

void ExtendSolidityParser::LocalVariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocalVariableDeclaration(this);
}

void ExtendSolidityParser::LocalVariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocalVariableDeclaration(this);
}


std::any ExtendSolidityParser::LocalVariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitLocalVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::LocalVariableDeclarationContext* ExtendSolidityParser::localVariableDeclaration() {
  LocalVariableDeclarationContext *_localctx = _tracker.createInstance<LocalVariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 124, ExtendSolidityParser::RuleLocalVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(739);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(732);
      match(ExtendSolidityParser::T__47);
      setState(733);
      identifierList();
      break;
    }

    case 2: {
      setState(734);
      variableDeclaration();
      break;
    }

    case 3: {
      setState(735);
      match(ExtendSolidityParser::T__20);
      setState(736);
      variableDeclarationList();
      setState(737);
      match(ExtendSolidityParser::T__21);
      break;
    }

    default:
      break;
    }
    setState(743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__8) {
      setState(741);
      match(ExtendSolidityParser::T__8);
      setState(742);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationListContext ------------------------------------------------------------------

ExtendSolidityParser::VariableDeclarationListContext::VariableDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::VariableDeclarationContext* ExtendSolidityParser::VariableDeclarationListContext::variableDeclaration() {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationContext>(0);
}

std::vector<ExtendSolidityParser::MoreVariableDeclarationContext *> ExtendSolidityParser::VariableDeclarationListContext::moreVariableDeclaration() {
  return getRuleContexts<ExtendSolidityParser::MoreVariableDeclarationContext>();
}

ExtendSolidityParser::MoreVariableDeclarationContext* ExtendSolidityParser::VariableDeclarationListContext::moreVariableDeclaration(size_t i) {
  return getRuleContext<ExtendSolidityParser::MoreVariableDeclarationContext>(i);
}


size_t ExtendSolidityParser::VariableDeclarationListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleVariableDeclarationList;
}

void ExtendSolidityParser::VariableDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclarationList(this);
}

void ExtendSolidityParser::VariableDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclarationList(this);
}


std::any ExtendSolidityParser::VariableDeclarationListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitVariableDeclarationList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::VariableDeclarationListContext* ExtendSolidityParser::variableDeclarationList() {
  VariableDeclarationListContext *_localctx = _tracker.createInstance<VariableDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 126, ExtendSolidityParser::RuleVariableDeclarationList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(745);
      variableDeclaration();
    }
    setState(751);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__14) {
      setState(748);
      moreVariableDeclaration();
      setState(753);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoreVariableDeclarationContext ------------------------------------------------------------------

ExtendSolidityParser::MoreVariableDeclarationContext::MoreVariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::VariableDeclarationContext* ExtendSolidityParser::MoreVariableDeclarationContext::variableDeclaration() {
  return getRuleContext<ExtendSolidityParser::VariableDeclarationContext>(0);
}


size_t ExtendSolidityParser::MoreVariableDeclarationContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMoreVariableDeclaration;
}

void ExtendSolidityParser::MoreVariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMoreVariableDeclaration(this);
}

void ExtendSolidityParser::MoreVariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMoreVariableDeclaration(this);
}


std::any ExtendSolidityParser::MoreVariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMoreVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MoreVariableDeclarationContext* ExtendSolidityParser::moreVariableDeclaration() {
  MoreVariableDeclarationContext *_localctx = _tracker.createInstance<MoreVariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 128, ExtendSolidityParser::RuleMoreVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(754);
    match(ExtendSolidityParser::T__14);
    setState(756);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31807265208016896) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 16777247) != 0)) {
      setState(755);
      variableDeclaration();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

ExtendSolidityParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::MoreIdentifierContext *> ExtendSolidityParser::IdentifierListContext::moreIdentifier() {
  return getRuleContexts<ExtendSolidityParser::MoreIdentifierContext>();
}

ExtendSolidityParser::MoreIdentifierContext* ExtendSolidityParser::IdentifierListContext::moreIdentifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::MoreIdentifierContext>(i);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::IdentifierListContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::IdentifierListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleIdentifierList;
}

void ExtendSolidityParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void ExtendSolidityParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}


std::any ExtendSolidityParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::IdentifierListContext* ExtendSolidityParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 130, ExtendSolidityParser::RuleIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(758);
    match(ExtendSolidityParser::T__20);
    setState(762);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(759);
        moreIdentifier(); 
      }
      setState(764);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx);
    }
    setState(766);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(765);
      identifier();
    }
    setState(768);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoreIdentifierContext ------------------------------------------------------------------

ExtendSolidityParser::MoreIdentifierContext::MoreIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::MoreIdentifierContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::MoreIdentifierContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMoreIdentifier;
}

void ExtendSolidityParser::MoreIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMoreIdentifier(this);
}

void ExtendSolidityParser::MoreIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMoreIdentifier(this);
}


std::any ExtendSolidityParser::MoreIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMoreIdentifier(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MoreIdentifierContext* ExtendSolidityParser::moreIdentifier() {
  MoreIdentifierContext *_localctx = _tracker.createInstance<MoreIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 132, ExtendSolidityParser::RuleMoreIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(771);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(770);
      identifier();
    }
    setState(773);
    match(ExtendSolidityParser::T__14);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementaryTypeNameContext ------------------------------------------------------------------

ExtendSolidityParser::ElementaryTypeNameContext::ElementaryTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::ElementaryTypeNameContext::Int() {
  return getToken(ExtendSolidityParser::Int, 0);
}

tree::TerminalNode* ExtendSolidityParser::ElementaryTypeNameContext::Uint() {
  return getToken(ExtendSolidityParser::Uint, 0);
}

tree::TerminalNode* ExtendSolidityParser::ElementaryTypeNameContext::Byte() {
  return getToken(ExtendSolidityParser::Byte, 0);
}

tree::TerminalNode* ExtendSolidityParser::ElementaryTypeNameContext::Fixed() {
  return getToken(ExtendSolidityParser::Fixed, 0);
}

tree::TerminalNode* ExtendSolidityParser::ElementaryTypeNameContext::Ufixed() {
  return getToken(ExtendSolidityParser::Ufixed, 0);
}


size_t ExtendSolidityParser::ElementaryTypeNameContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleElementaryTypeName;
}

void ExtendSolidityParser::ElementaryTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementaryTypeName(this);
}

void ExtendSolidityParser::ElementaryTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementaryTypeName(this);
}


std::any ExtendSolidityParser::ElementaryTypeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitElementaryTypeName(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ElementaryTypeNameContext* ExtendSolidityParser::elementaryTypeName() {
  ElementaryTypeNameContext *_localctx = _tracker.createInstance<ElementaryTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 134, ExtendSolidityParser::RuleElementaryTypeName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(775);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 31806680958238720) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 100)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::ExpressionContext *> ExtendSolidityParser::ExpressionContext::expression() {
  return getRuleContexts<ExtendSolidityParser::ExpressionContext>();
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(i);
}

ExtendSolidityParser::PreOperatorContext* ExtendSolidityParser::ExpressionContext::preOperator() {
  return getRuleContext<ExtendSolidityParser::PreOperatorContext>(0);
}

ExtendSolidityParser::TypeNameContext* ExtendSolidityParser::ExpressionContext::typeName() {
  return getRuleContext<ExtendSolidityParser::TypeNameContext>(0);
}

ExtendSolidityParser::PrimaryExpressionContext* ExtendSolidityParser::ExpressionContext::primaryExpression() {
  return getRuleContext<ExtendSolidityParser::PrimaryExpressionContext>(0);
}

ExtendSolidityParser::MidOperatorContext* ExtendSolidityParser::ExpressionContext::midOperator() {
  return getRuleContext<ExtendSolidityParser::MidOperatorContext>(0);
}

ExtendSolidityParser::PostOperatorContext* ExtendSolidityParser::ExpressionContext::postOperator() {
  return getRuleContext<ExtendSolidityParser::PostOperatorContext>(0);
}

ExtendSolidityParser::FunctionCallArgumentsContext* ExtendSolidityParser::ExpressionContext::functionCallArguments() {
  return getRuleContext<ExtendSolidityParser::FunctionCallArgumentsContext>(0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::ExpressionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::ExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleExpression;
}

void ExtendSolidityParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void ExtendSolidityParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any ExtendSolidityParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::expression() {
   return expression(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ExtendSolidityParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  ExtendSolidityParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 136;
  enterRecursionRule(_localctx, 136, ExtendSolidityParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(794);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      setState(778);
      match(ExtendSolidityParser::T__20);
      setState(779);
      expression(0);
      setState(780);
      match(ExtendSolidityParser::T__21);
      antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  4;
      break;
    }

    case 2: {
      setState(783);
      preOperator();
      setState(784);
      expression(5);
      antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  5;
      break;
    }

    case 3: {
      setState(787);
      match(ExtendSolidityParser::T__54);
      setState(788);
      typeName(0);
      antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  6;
      break;
    }

    case 4: {
      setState(791);
      primaryExpression();
      antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  9;
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(831);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(829);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(796);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(797);
          midOperator();
          setState(798);
          expression(4);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  7;
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(801);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(802);
          match(ExtendSolidityParser::T__55);
          setState(803);
          expression(0);
          setState(804);
          match(ExtendSolidityParser::T__56);
          setState(805);
          expression(3);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  8;
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(808);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(809);
          postOperator();
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  0;
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(812);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(813);
          match(ExtendSolidityParser::T__30);
          setState(814);
          expression(0);
          setState(815);
          match(ExtendSolidityParser::T__31);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  1;
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(818);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(819);
          match(ExtendSolidityParser::T__20);
          setState(820);
          functionCallArguments();
          setState(821);
          match(ExtendSolidityParser::T__21);
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  2;
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(824);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(825);
          match(ExtendSolidityParser::T__33);
          setState(826);
          identifier();
          antlrcpp::downCast<ExpressionContext *>(_localctx)->expressionType =  3;
          break;
        }

        default:
          break;
        } 
      }
      setState(833);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PostOperatorContext ------------------------------------------------------------------

ExtendSolidityParser::PostOperatorContext::PostOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::PostOperatorContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePostOperator;
}

void ExtendSolidityParser::PostOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostOperator(this);
}

void ExtendSolidityParser::PostOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostOperator(this);
}


std::any ExtendSolidityParser::PostOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPostOperator(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PostOperatorContext* ExtendSolidityParser::postOperator() {
  PostOperatorContext *_localctx = _tracker.createInstance<PostOperatorContext>(_ctx, getState());
  enterRule(_localctx, 138, ExtendSolidityParser::RulePostOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(834);
    _la = _input->LA(1);
    if (!(_la == ExtendSolidityParser::T__57

    || _la == ExtendSolidityParser::T__58)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreOperatorContext ------------------------------------------------------------------

ExtendSolidityParser::PreOperatorContext::PreOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::PreOperatorContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePreOperator;
}

void ExtendSolidityParser::PreOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreOperator(this);
}

void ExtendSolidityParser::PreOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreOperator(this);
}


std::any ExtendSolidityParser::PreOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPreOperator(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PreOperatorContext* ExtendSolidityParser::preOperator() {
  PreOperatorContext *_localctx = _tracker.createInstance<PreOperatorContext>(_ctx, getState());
  enterRule(_localctx, 140, ExtendSolidityParser::RulePreOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(836);
    _la = _input->LA(1);
    if (!(((((_la - 4) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 4)) & 2287828610704211969) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MidOperatorContext ------------------------------------------------------------------

ExtendSolidityParser::MidOperatorContext::MidOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::MidOperatorContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMidOperator;
}

void ExtendSolidityParser::MidOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMidOperator(this);
}

void ExtendSolidityParser::MidOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMidOperator(this);
}


std::any ExtendSolidityParser::MidOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMidOperator(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MidOperatorContext* ExtendSolidityParser::midOperator() {
  MidOperatorContext *_localctx = _tracker.createInstance<MidOperatorContext>(_ctx, getState());
  enterRule(_localctx, 142, ExtendSolidityParser::RuleMidOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(838);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3458764513820546024) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 2097151) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::PrimaryExpressionContext::BooleanLiteral() {
  return getToken(ExtendSolidityParser::BooleanLiteral, 0);
}

ExtendSolidityParser::NumberLiteralContext* ExtendSolidityParser::PrimaryExpressionContext::numberLiteral() {
  return getRuleContext<ExtendSolidityParser::NumberLiteralContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::PrimaryExpressionContext::HexLiteral() {
  return getToken(ExtendSolidityParser::HexLiteral, 0);
}

tree::TerminalNode* ExtendSolidityParser::PrimaryExpressionContext::StringLiteral() {
  return getToken(ExtendSolidityParser::StringLiteral, 0);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::PrimaryExpressionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::MatchedParenthesesContext* ExtendSolidityParser::PrimaryExpressionContext::matchedParentheses() {
  return getRuleContext<ExtendSolidityParser::MatchedParenthesesContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::PrimaryExpressionContext::TypeKeyword() {
  return getToken(ExtendSolidityParser::TypeKeyword, 0);
}

ExtendSolidityParser::TupleExpressionContext* ExtendSolidityParser::PrimaryExpressionContext::tupleExpression() {
  return getRuleContext<ExtendSolidityParser::TupleExpressionContext>(0);
}

ExtendSolidityParser::TypeNameExpressionContext* ExtendSolidityParser::PrimaryExpressionContext::typeNameExpression() {
  return getRuleContext<ExtendSolidityParser::TypeNameExpressionContext>(0);
}


size_t ExtendSolidityParser::PrimaryExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RulePrimaryExpression;
}

void ExtendSolidityParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void ExtendSolidityParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}


std::any ExtendSolidityParser::PrimaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::PrimaryExpressionContext* ExtendSolidityParser::primaryExpression() {
  PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 144, ExtendSolidityParser::RulePrimaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(854);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(840);
      match(ExtendSolidityParser::BooleanLiteral);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(841);
      numberLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(842);
      match(ExtendSolidityParser::HexLiteral);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(843);
      match(ExtendSolidityParser::StringLiteral);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(844);
      identifier();
      setState(846);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
      case 1: {
        setState(845);
        matchedParentheses();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(848);
      match(ExtendSolidityParser::TypeKeyword);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(849);
      tupleExpression();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(850);
      typeNameExpression();
      setState(852);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
      case 1: {
        setState(851);
        matchedParentheses();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MatchedParenthesesContext ------------------------------------------------------------------

ExtendSolidityParser::MatchedParenthesesContext::MatchedParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExtendSolidityParser::MatchedParenthesesContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMatchedParentheses;
}

void ExtendSolidityParser::MatchedParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatchedParentheses(this);
}

void ExtendSolidityParser::MatchedParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatchedParentheses(this);
}


std::any ExtendSolidityParser::MatchedParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMatchedParentheses(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MatchedParenthesesContext* ExtendSolidityParser::matchedParentheses() {
  MatchedParenthesesContext *_localctx = _tracker.createInstance<MatchedParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 146, ExtendSolidityParser::RuleMatchedParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    match(ExtendSolidityParser::T__30);
    setState(857);
    match(ExtendSolidityParser::T__31);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

ExtendSolidityParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::ExpressionContext *> ExtendSolidityParser::ExpressionListContext::expression() {
  return getRuleContexts<ExtendSolidityParser::ExpressionContext>();
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(i);
}


size_t ExtendSolidityParser::ExpressionListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleExpressionList;
}

void ExtendSolidityParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void ExtendSolidityParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}


std::any ExtendSolidityParser::ExpressionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ExpressionListContext* ExtendSolidityParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 148, ExtendSolidityParser::RuleExpressionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(859);
    expression(0);
    setState(864);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__14) {
      setState(860);
      match(ExtendSolidityParser::T__14);
      setState(861);
      expression(0);
      setState(866);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueListContext ------------------------------------------------------------------

ExtendSolidityParser::NameValueListContext::NameValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::NameValueContext *> ExtendSolidityParser::NameValueListContext::nameValue() {
  return getRuleContexts<ExtendSolidityParser::NameValueContext>();
}

ExtendSolidityParser::NameValueContext* ExtendSolidityParser::NameValueListContext::nameValue(size_t i) {
  return getRuleContext<ExtendSolidityParser::NameValueContext>(i);
}


size_t ExtendSolidityParser::NameValueListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleNameValueList;
}

void ExtendSolidityParser::NameValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueList(this);
}

void ExtendSolidityParser::NameValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueList(this);
}


std::any ExtendSolidityParser::NameValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitNameValueList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::NameValueListContext* ExtendSolidityParser::nameValueList() {
  NameValueListContext *_localctx = _tracker.createInstance<NameValueListContext>(_ctx, getState());
  enterRule(_localctx, 150, ExtendSolidityParser::RuleNameValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(867);
    nameValue();
    setState(872);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(868);
        match(ExtendSolidityParser::T__14);
        setState(869);
        nameValue(); 
      }
      setState(874);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    }
    setState(876);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__14) {
      setState(875);
      match(ExtendSolidityParser::T__14);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueContext ------------------------------------------------------------------

ExtendSolidityParser::NameValueContext::NameValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::NameValueContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::NameValueContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::NameValueContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleNameValue;
}

void ExtendSolidityParser::NameValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValue(this);
}

void ExtendSolidityParser::NameValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValue(this);
}


std::any ExtendSolidityParser::NameValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitNameValue(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::NameValueContext* ExtendSolidityParser::nameValue() {
  NameValueContext *_localctx = _tracker.createInstance<NameValueContext>(_ctx, getState());
  enterRule(_localctx, 152, ExtendSolidityParser::RuleNameValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(878);
    identifier();
    setState(879);
    match(ExtendSolidityParser::T__56);
    setState(880);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallArgumentsContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionCallArgumentsContext::FunctionCallArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::NameValueListContext* ExtendSolidityParser::FunctionCallArgumentsContext::nameValueList() {
  return getRuleContext<ExtendSolidityParser::NameValueListContext>(0);
}

ExtendSolidityParser::ExpressionListContext* ExtendSolidityParser::FunctionCallArgumentsContext::expressionList() {
  return getRuleContext<ExtendSolidityParser::ExpressionListContext>(0);
}


size_t ExtendSolidityParser::FunctionCallArgumentsContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionCallArguments;
}

void ExtendSolidityParser::FunctionCallArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallArguments(this);
}

void ExtendSolidityParser::FunctionCallArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallArguments(this);
}


std::any ExtendSolidityParser::FunctionCallArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionCallArguments(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionCallArgumentsContext* ExtendSolidityParser::functionCallArguments() {
  FunctionCallArgumentsContext *_localctx = _tracker.createInstance<FunctionCallArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 154, ExtendSolidityParser::RuleFunctionCallArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(890);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__13: {
        enterOuterAlt(_localctx, 1);
        setState(882);
        match(ExtendSolidityParser::T__13);
        setState(884);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ExtendSolidityParser::T__12

        || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
          setState(883);
          nameValueList();
        }
        setState(886);
        match(ExtendSolidityParser::T__15);
        break;
      }

      case ExtendSolidityParser::T__3:
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__20:
      case ExtendSolidityParser::T__21:
      case ExtendSolidityParser::T__30:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__47:
      case ExtendSolidityParser::T__51:
      case ExtendSolidityParser::T__52:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::T__54:
      case ExtendSolidityParser::T__57:
      case ExtendSolidityParser::T__58:
      case ExtendSolidityParser::T__59:
      case ExtendSolidityParser::T__60:
      case ExtendSolidityParser::T__61:
      case ExtendSolidityParser::T__62:
      case ExtendSolidityParser::T__63:
      case ExtendSolidityParser::BooleanLiteral:
      case ExtendSolidityParser::DecimalNumber:
      case ExtendSolidityParser::HexNumber:
      case ExtendSolidityParser::Int:
      case ExtendSolidityParser::Uint:
      case ExtendSolidityParser::Byte:
      case ExtendSolidityParser::Fixed:
      case ExtendSolidityParser::Ufixed:
      case ExtendSolidityParser::HexLiteral:
      case ExtendSolidityParser::TypeKeyword:
      case ExtendSolidityParser::Identifier:
      case ExtendSolidityParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(888);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
          setState(887);
          expressionList();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

ExtendSolidityParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::FunctionCallContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

ExtendSolidityParser::FunctionCallArgumentsContext* ExtendSolidityParser::FunctionCallContext::functionCallArguments() {
  return getRuleContext<ExtendSolidityParser::FunctionCallArgumentsContext>(0);
}


size_t ExtendSolidityParser::FunctionCallContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleFunctionCall;
}

void ExtendSolidityParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void ExtendSolidityParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}


std::any ExtendSolidityParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::FunctionCallContext* ExtendSolidityParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 156, ExtendSolidityParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(892);
    expression(0);
    setState(893);
    match(ExtendSolidityParser::T__20);
    setState(894);
    functionCallArguments();
    setState(895);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyBlockContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyBlockContext::AssemblyBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::AssemblyItemContext *> ExtendSolidityParser::AssemblyBlockContext::assemblyItem() {
  return getRuleContexts<ExtendSolidityParser::AssemblyItemContext>();
}

ExtendSolidityParser::AssemblyItemContext* ExtendSolidityParser::AssemblyBlockContext::assemblyItem(size_t i) {
  return getRuleContext<ExtendSolidityParser::AssemblyItemContext>(i);
}


size_t ExtendSolidityParser::AssemblyBlockContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyBlock;
}

void ExtendSolidityParser::AssemblyBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyBlock(this);
}

void ExtendSolidityParser::AssemblyBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyBlock(this);
}


std::any ExtendSolidityParser::AssemblyBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyBlock(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::assemblyBlock() {
  AssemblyBlockContext *_localctx = _tracker.createInstance<AssemblyBlockContext>(_ctx, getState());
  enterRule(_localctx, 158, ExtendSolidityParser::RuleAssemblyBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(897);
    match(ExtendSolidityParser::T__13);
    setState(901);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 18060036985085952) != 0) || ((((_la - 86) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 86)) & 824676724749) != 0)) {
      setState(898);
      assemblyItem();
      setState(903);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(904);
    match(ExtendSolidityParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyItemContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyItemContext::AssemblyItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyItemContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::AssemblyItemContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyItemContext::assemblyExpression() {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(0);
}

ExtendSolidityParser::AssemblyLocalDefinitionContext* ExtendSolidityParser::AssemblyItemContext::assemblyLocalDefinition() {
  return getRuleContext<ExtendSolidityParser::AssemblyLocalDefinitionContext>(0);
}

ExtendSolidityParser::AssemblyAssignmentContext* ExtendSolidityParser::AssemblyItemContext::assemblyAssignment() {
  return getRuleContext<ExtendSolidityParser::AssemblyAssignmentContext>(0);
}

ExtendSolidityParser::AssemblyStackAssignmentContext* ExtendSolidityParser::AssemblyItemContext::assemblyStackAssignment() {
  return getRuleContext<ExtendSolidityParser::AssemblyStackAssignmentContext>(0);
}

ExtendSolidityParser::LabelDefinitionContext* ExtendSolidityParser::AssemblyItemContext::labelDefinition() {
  return getRuleContext<ExtendSolidityParser::LabelDefinitionContext>(0);
}

ExtendSolidityParser::AssemblySwitchContext* ExtendSolidityParser::AssemblyItemContext::assemblySwitch() {
  return getRuleContext<ExtendSolidityParser::AssemblySwitchContext>(0);
}

ExtendSolidityParser::AssemblyFunctionDefinitionContext* ExtendSolidityParser::AssemblyItemContext::assemblyFunctionDefinition() {
  return getRuleContext<ExtendSolidityParser::AssemblyFunctionDefinitionContext>(0);
}

ExtendSolidityParser::AssemblyForContext* ExtendSolidityParser::AssemblyItemContext::assemblyFor() {
  return getRuleContext<ExtendSolidityParser::AssemblyForContext>(0);
}

ExtendSolidityParser::AssemblyIfContext* ExtendSolidityParser::AssemblyItemContext::assemblyIf() {
  return getRuleContext<ExtendSolidityParser::AssemblyIfContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyItemContext::BreakKeyword() {
  return getToken(ExtendSolidityParser::BreakKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyItemContext::ContinueKeyword() {
  return getToken(ExtendSolidityParser::ContinueKeyword, 0);
}

ExtendSolidityParser::SubAssemblyContext* ExtendSolidityParser::AssemblyItemContext::subAssembly() {
  return getRuleContext<ExtendSolidityParser::SubAssemblyContext>(0);
}

ExtendSolidityParser::NumberLiteralContext* ExtendSolidityParser::AssemblyItemContext::numberLiteral() {
  return getRuleContext<ExtendSolidityParser::NumberLiteralContext>(0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyItemContext::StringLiteral() {
  return getToken(ExtendSolidityParser::StringLiteral, 0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyItemContext::HexLiteral() {
  return getToken(ExtendSolidityParser::HexLiteral, 0);
}


size_t ExtendSolidityParser::AssemblyItemContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyItem;
}

void ExtendSolidityParser::AssemblyItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyItem(this);
}

void ExtendSolidityParser::AssemblyItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyItem(this);
}


std::any ExtendSolidityParser::AssemblyItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyItem(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyItemContext* ExtendSolidityParser::assemblyItem() {
  AssemblyItemContext *_localctx = _tracker.createInstance<AssemblyItemContext>(_ctx, getState());
  enterRule(_localctx, 160, ExtendSolidityParser::RuleAssemblyItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(923);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(906);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(907);
      assemblyBlock();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(908);
      assemblyExpression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(909);
      assemblyLocalDefinition();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(910);
      assemblyAssignment();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(911);
      assemblyStackAssignment();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(912);
      labelDefinition();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(913);
      assemblySwitch();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(914);
      assemblyFunctionDefinition();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(915);
      assemblyFor();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(916);
      assemblyIf();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(917);
      match(ExtendSolidityParser::BreakKeyword);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(918);
      match(ExtendSolidityParser::ContinueKeyword);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(919);
      subAssembly();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(920);
      numberLiteral();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(921);
      match(ExtendSolidityParser::StringLiteral);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(922);
      match(ExtendSolidityParser::HexLiteral);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyExpressionContext::AssemblyExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyCallContext* ExtendSolidityParser::AssemblyExpressionContext::assemblyCall() {
  return getRuleContext<ExtendSolidityParser::AssemblyCallContext>(0);
}

ExtendSolidityParser::AssemblyLiteralContext* ExtendSolidityParser::AssemblyExpressionContext::assemblyLiteral() {
  return getRuleContext<ExtendSolidityParser::AssemblyLiteralContext>(0);
}


size_t ExtendSolidityParser::AssemblyExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyExpression;
}

void ExtendSolidityParser::AssemblyExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyExpression(this);
}

void ExtendSolidityParser::AssemblyExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyExpression(this);
}


std::any ExtendSolidityParser::AssemblyExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::assemblyExpression() {
  AssemblyExpressionContext *_localctx = _tracker.createInstance<AssemblyExpressionContext>(_ctx, getState());
  enterRule(_localctx, 162, ExtendSolidityParser::RuleAssemblyExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(927);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__44:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(925);
        assemblyCall();
        break;
      }

      case ExtendSolidityParser::DecimalNumber:
      case ExtendSolidityParser::HexNumber:
      case ExtendSolidityParser::HexLiteral:
      case ExtendSolidityParser::StringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(926);
        assemblyLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyCallContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyCallContext::AssemblyCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyCallContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

std::vector<ExtendSolidityParser::AssemblyExpressionContext *> ExtendSolidityParser::AssemblyCallContext::assemblyExpression() {
  return getRuleContexts<ExtendSolidityParser::AssemblyExpressionContext>();
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyCallContext::assemblyExpression(size_t i) {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(i);
}


size_t ExtendSolidityParser::AssemblyCallContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyCall;
}

void ExtendSolidityParser::AssemblyCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyCall(this);
}

void ExtendSolidityParser::AssemblyCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyCall(this);
}


std::any ExtendSolidityParser::AssemblyCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyCall(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyCallContext* ExtendSolidityParser::assemblyCall() {
  AssemblyCallContext *_localctx = _tracker.createInstance<AssemblyCallContext>(_ctx, getState());
  enterRule(_localctx, 164, ExtendSolidityParser::RuleAssemblyCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(933);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__44: {
        setState(929);
        match(ExtendSolidityParser::T__44);
        break;
      }

      case ExtendSolidityParser::T__32: {
        setState(930);
        match(ExtendSolidityParser::T__32);
        break;
      }

      case ExtendSolidityParser::T__53: {
        setState(931);
        match(ExtendSolidityParser::T__53);
        break;
      }

      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::Identifier: {
        setState(932);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(947);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      setState(935);
      match(ExtendSolidityParser::T__20);
      setState(937);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 18050141227327488) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 98)) & 201326851) != 0)) {
        setState(936);
        assemblyExpression();
      }
      setState(943);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(939);
        match(ExtendSolidityParser::T__14);
        setState(940);
        assemblyExpression();
        setState(945);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(946);
      match(ExtendSolidityParser::T__21);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyLocalDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyLocalDefinitionContext::AssemblyLocalDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyIdentifierOrListContext* ExtendSolidityParser::AssemblyLocalDefinitionContext::assemblyIdentifierOrList() {
  return getRuleContext<ExtendSolidityParser::AssemblyIdentifierOrListContext>(0);
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyLocalDefinitionContext::assemblyExpression() {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(0);
}


size_t ExtendSolidityParser::AssemblyLocalDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyLocalDefinition;
}

void ExtendSolidityParser::AssemblyLocalDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyLocalDefinition(this);
}

void ExtendSolidityParser::AssemblyLocalDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyLocalDefinition(this);
}


std::any ExtendSolidityParser::AssemblyLocalDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyLocalDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyLocalDefinitionContext* ExtendSolidityParser::assemblyLocalDefinition() {
  AssemblyLocalDefinitionContext *_localctx = _tracker.createInstance<AssemblyLocalDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 166, ExtendSolidityParser::RuleAssemblyLocalDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(949);
    match(ExtendSolidityParser::T__85);
    setState(950);
    assemblyIdentifierOrList();
    setState(953);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__86) {
      setState(951);
      match(ExtendSolidityParser::T__86);
      setState(952);
      assemblyExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyAssignmentContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyAssignmentContext::AssemblyAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyIdentifierOrListContext* ExtendSolidityParser::AssemblyAssignmentContext::assemblyIdentifierOrList() {
  return getRuleContext<ExtendSolidityParser::AssemblyIdentifierOrListContext>(0);
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyAssignmentContext::assemblyExpression() {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(0);
}


size_t ExtendSolidityParser::AssemblyAssignmentContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyAssignment;
}

void ExtendSolidityParser::AssemblyAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyAssignment(this);
}

void ExtendSolidityParser::AssemblyAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyAssignment(this);
}


std::any ExtendSolidityParser::AssemblyAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyAssignment(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyAssignmentContext* ExtendSolidityParser::assemblyAssignment() {
  AssemblyAssignmentContext *_localctx = _tracker.createInstance<AssemblyAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 168, ExtendSolidityParser::RuleAssemblyAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(955);
    assemblyIdentifierOrList();
    setState(956);
    match(ExtendSolidityParser::T__86);
    setState(957);
    assemblyExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyIdentifierOrListContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyIdentifierOrListContext::AssemblyIdentifierOrListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyIdentifierOrListContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::AssemblyIdentifierListContext* ExtendSolidityParser::AssemblyIdentifierOrListContext::assemblyIdentifierList() {
  return getRuleContext<ExtendSolidityParser::AssemblyIdentifierListContext>(0);
}


size_t ExtendSolidityParser::AssemblyIdentifierOrListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyIdentifierOrList;
}

void ExtendSolidityParser::AssemblyIdentifierOrListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyIdentifierOrList(this);
}

void ExtendSolidityParser::AssemblyIdentifierOrListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyIdentifierOrList(this);
}


std::any ExtendSolidityParser::AssemblyIdentifierOrListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyIdentifierOrList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyIdentifierOrListContext* ExtendSolidityParser::assemblyIdentifierOrList() {
  AssemblyIdentifierOrListContext *_localctx = _tracker.createInstance<AssemblyIdentifierOrListContext>(_ctx, getState());
  enterRule(_localctx, 170, ExtendSolidityParser::RuleAssemblyIdentifierOrList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(964);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(959);
        identifier();
        break;
      }

      case ExtendSolidityParser::T__20: {
        enterOuterAlt(_localctx, 2);
        setState(960);
        match(ExtendSolidityParser::T__20);
        setState(961);
        assemblyIdentifierList();
        setState(962);
        match(ExtendSolidityParser::T__21);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyIdentifierListContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyIdentifierListContext::AssemblyIdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::IdentifierContext *> ExtendSolidityParser::AssemblyIdentifierListContext::identifier() {
  return getRuleContexts<ExtendSolidityParser::IdentifierContext>();
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyIdentifierListContext::identifier(size_t i) {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(i);
}


size_t ExtendSolidityParser::AssemblyIdentifierListContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyIdentifierList;
}

void ExtendSolidityParser::AssemblyIdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyIdentifierList(this);
}

void ExtendSolidityParser::AssemblyIdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyIdentifierList(this);
}


std::any ExtendSolidityParser::AssemblyIdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyIdentifierListContext* ExtendSolidityParser::assemblyIdentifierList() {
  AssemblyIdentifierListContext *_localctx = _tracker.createInstance<AssemblyIdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 172, ExtendSolidityParser::RuleAssemblyIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(966);
    identifier();
    setState(971);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__14) {
      setState(967);
      match(ExtendSolidityParser::T__14);
      setState(968);
      identifier();
      setState(973);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyStackAssignmentContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyStackAssignmentContext::AssemblyStackAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyStackAssignmentContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::AssemblyStackAssignmentContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyStackAssignment;
}

void ExtendSolidityParser::AssemblyStackAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyStackAssignment(this);
}

void ExtendSolidityParser::AssemblyStackAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyStackAssignment(this);
}


std::any ExtendSolidityParser::AssemblyStackAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyStackAssignment(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyStackAssignmentContext* ExtendSolidityParser::assemblyStackAssignment() {
  AssemblyStackAssignmentContext *_localctx = _tracker.createInstance<AssemblyStackAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 174, ExtendSolidityParser::RuleAssemblyStackAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(974);
    match(ExtendSolidityParser::T__87);
    setState(975);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::LabelDefinitionContext::LabelDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::LabelDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}


size_t ExtendSolidityParser::LabelDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleLabelDefinition;
}

void ExtendSolidityParser::LabelDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelDefinition(this);
}

void ExtendSolidityParser::LabelDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelDefinition(this);
}


std::any ExtendSolidityParser::LabelDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitLabelDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::LabelDefinitionContext* ExtendSolidityParser::labelDefinition() {
  LabelDefinitionContext *_localctx = _tracker.createInstance<LabelDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 176, ExtendSolidityParser::RuleLabelDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(977);
    identifier();
    setState(978);
    match(ExtendSolidityParser::T__56);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblySwitchContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblySwitchContext::AssemblySwitchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblySwitchContext::assemblyExpression() {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(0);
}

std::vector<ExtendSolidityParser::AssemblyCaseContext *> ExtendSolidityParser::AssemblySwitchContext::assemblyCase() {
  return getRuleContexts<ExtendSolidityParser::AssemblyCaseContext>();
}

ExtendSolidityParser::AssemblyCaseContext* ExtendSolidityParser::AssemblySwitchContext::assemblyCase(size_t i) {
  return getRuleContext<ExtendSolidityParser::AssemblyCaseContext>(i);
}


size_t ExtendSolidityParser::AssemblySwitchContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblySwitch;
}

void ExtendSolidityParser::AssemblySwitchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblySwitch(this);
}

void ExtendSolidityParser::AssemblySwitchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblySwitch(this);
}


std::any ExtendSolidityParser::AssemblySwitchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblySwitch(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblySwitchContext* ExtendSolidityParser::assemblySwitch() {
  AssemblySwitchContext *_localctx = _tracker.createInstance<AssemblySwitchContext>(_ctx, getState());
  enterRule(_localctx, 178, ExtendSolidityParser::RuleAssemblySwitch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(980);
    match(ExtendSolidityParser::T__88);
    setState(981);
    assemblyExpression();
    setState(985);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__89

    || _la == ExtendSolidityParser::T__90) {
      setState(982);
      assemblyCase();
      setState(987);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyCaseContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyCaseContext::AssemblyCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyLiteralContext* ExtendSolidityParser::AssemblyCaseContext::assemblyLiteral() {
  return getRuleContext<ExtendSolidityParser::AssemblyLiteralContext>(0);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::AssemblyCaseContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}


size_t ExtendSolidityParser::AssemblyCaseContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyCase;
}

void ExtendSolidityParser::AssemblyCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyCase(this);
}

void ExtendSolidityParser::AssemblyCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyCase(this);
}


std::any ExtendSolidityParser::AssemblyCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyCase(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyCaseContext* ExtendSolidityParser::assemblyCase() {
  AssemblyCaseContext *_localctx = _tracker.createInstance<AssemblyCaseContext>(_ctx, getState());
  enterRule(_localctx, 180, ExtendSolidityParser::RuleAssemblyCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(994);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__89: {
        enterOuterAlt(_localctx, 1);
        setState(988);
        match(ExtendSolidityParser::T__89);
        setState(989);
        assemblyLiteral();
        setState(990);
        assemblyBlock();
        break;
      }

      case ExtendSolidityParser::T__90: {
        enterOuterAlt(_localctx, 2);
        setState(992);
        match(ExtendSolidityParser::T__90);
        setState(993);
        assemblyBlock();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyFunctionDefinitionContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyFunctionDefinitionContext::AssemblyFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::AssemblyFunctionDefinitionContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::AssemblyFunctionDefinitionContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}

ExtendSolidityParser::AssemblyIdentifierListContext* ExtendSolidityParser::AssemblyFunctionDefinitionContext::assemblyIdentifierList() {
  return getRuleContext<ExtendSolidityParser::AssemblyIdentifierListContext>(0);
}

ExtendSolidityParser::AssemblyFunctionReturnsContext* ExtendSolidityParser::AssemblyFunctionDefinitionContext::assemblyFunctionReturns() {
  return getRuleContext<ExtendSolidityParser::AssemblyFunctionReturnsContext>(0);
}


size_t ExtendSolidityParser::AssemblyFunctionDefinitionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyFunctionDefinition;
}

void ExtendSolidityParser::AssemblyFunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFunctionDefinition(this);
}

void ExtendSolidityParser::AssemblyFunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFunctionDefinition(this);
}


std::any ExtendSolidityParser::AssemblyFunctionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyFunctionDefinition(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyFunctionDefinitionContext* ExtendSolidityParser::assemblyFunctionDefinition() {
  AssemblyFunctionDefinitionContext *_localctx = _tracker.createInstance<AssemblyFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 182, ExtendSolidityParser::RuleAssemblyFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(996);
    match(ExtendSolidityParser::T__26);
    setState(997);
    identifier();
    setState(998);
    match(ExtendSolidityParser::T__20);
    setState(1000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier) {
      setState(999);
      assemblyIdentifierList();
    }
    setState(1002);
    match(ExtendSolidityParser::T__21);
    setState(1004);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExtendSolidityParser::T__91) {
      setState(1003);
      assemblyFunctionReturns();
    }
    setState(1006);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyFunctionReturnsContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyFunctionReturnsContext::AssemblyFunctionReturnsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyIdentifierListContext* ExtendSolidityParser::AssemblyFunctionReturnsContext::assemblyIdentifierList() {
  return getRuleContext<ExtendSolidityParser::AssemblyIdentifierListContext>(0);
}


size_t ExtendSolidityParser::AssemblyFunctionReturnsContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyFunctionReturns;
}

void ExtendSolidityParser::AssemblyFunctionReturnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFunctionReturns(this);
}

void ExtendSolidityParser::AssemblyFunctionReturnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFunctionReturns(this);
}


std::any ExtendSolidityParser::AssemblyFunctionReturnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyFunctionReturns(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyFunctionReturnsContext* ExtendSolidityParser::assemblyFunctionReturns() {
  AssemblyFunctionReturnsContext *_localctx = _tracker.createInstance<AssemblyFunctionReturnsContext>(_ctx, getState());
  enterRule(_localctx, 184, ExtendSolidityParser::RuleAssemblyFunctionReturns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1008);
    match(ExtendSolidityParser::T__91);
    setState(1009);
    assemblyIdentifierList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyForContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyForContext::AssemblyForContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::AssemblyExpressionContext *> ExtendSolidityParser::AssemblyForContext::assemblyExpression() {
  return getRuleContexts<ExtendSolidityParser::AssemblyExpressionContext>();
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyForContext::assemblyExpression(size_t i) {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(i);
}

std::vector<ExtendSolidityParser::AssemblyBlockContext *> ExtendSolidityParser::AssemblyForContext::assemblyBlock() {
  return getRuleContexts<ExtendSolidityParser::AssemblyBlockContext>();
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::AssemblyForContext::assemblyBlock(size_t i) {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(i);
}


size_t ExtendSolidityParser::AssemblyForContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyFor;
}

void ExtendSolidityParser::AssemblyForContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyFor(this);
}

void ExtendSolidityParser::AssemblyForContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyFor(this);
}


std::any ExtendSolidityParser::AssemblyForContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyFor(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyForContext* ExtendSolidityParser::assemblyFor() {
  AssemblyForContext *_localctx = _tracker.createInstance<AssemblyForContext>(_ctx, getState());
  enterRule(_localctx, 186, ExtendSolidityParser::RuleAssemblyFor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1011);
    match(ExtendSolidityParser::T__23);
    setState(1014);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__13: {
        setState(1012);
        assemblyBlock();
        break;
      }

      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__44:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::DecimalNumber:
      case ExtendSolidityParser::HexNumber:
      case ExtendSolidityParser::HexLiteral:
      case ExtendSolidityParser::Identifier:
      case ExtendSolidityParser::StringLiteral: {
        setState(1013);
        assemblyExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1016);
    assemblyExpression();
    setState(1019);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__13: {
        setState(1017);
        assemblyBlock();
        break;
      }

      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::T__44:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::DecimalNumber:
      case ExtendSolidityParser::HexNumber:
      case ExtendSolidityParser::HexLiteral:
      case ExtendSolidityParser::Identifier:
      case ExtendSolidityParser::StringLiteral: {
        setState(1018);
        assemblyExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1021);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyIfContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyIfContext::AssemblyIfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::AssemblyExpressionContext* ExtendSolidityParser::AssemblyIfContext::assemblyExpression() {
  return getRuleContext<ExtendSolidityParser::AssemblyExpressionContext>(0);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::AssemblyIfContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}


size_t ExtendSolidityParser::AssemblyIfContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyIf;
}

void ExtendSolidityParser::AssemblyIfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyIf(this);
}

void ExtendSolidityParser::AssemblyIfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyIf(this);
}


std::any ExtendSolidityParser::AssemblyIfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyIf(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyIfContext* ExtendSolidityParser::assemblyIf() {
  AssemblyIfContext *_localctx = _tracker.createInstance<AssemblyIfContext>(_ctx, getState());
  enterRule(_localctx, 188, ExtendSolidityParser::RuleAssemblyIf);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1023);
    match(ExtendSolidityParser::T__39);
    setState(1024);
    assemblyExpression();
    setState(1025);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssemblyLiteralContext ------------------------------------------------------------------

ExtendSolidityParser::AssemblyLiteralContext::AssemblyLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::AssemblyLiteralContext::StringLiteral() {
  return getToken(ExtendSolidityParser::StringLiteral, 0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyLiteralContext::DecimalNumber() {
  return getToken(ExtendSolidityParser::DecimalNumber, 0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyLiteralContext::HexNumber() {
  return getToken(ExtendSolidityParser::HexNumber, 0);
}

tree::TerminalNode* ExtendSolidityParser::AssemblyLiteralContext::HexLiteral() {
  return getToken(ExtendSolidityParser::HexLiteral, 0);
}


size_t ExtendSolidityParser::AssemblyLiteralContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAssemblyLiteral;
}

void ExtendSolidityParser::AssemblyLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssemblyLiteral(this);
}

void ExtendSolidityParser::AssemblyLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssemblyLiteral(this);
}


std::any ExtendSolidityParser::AssemblyLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAssemblyLiteral(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AssemblyLiteralContext* ExtendSolidityParser::assemblyLiteral() {
  AssemblyLiteralContext *_localctx = _tracker.createInstance<AssemblyLiteralContext>(_ctx, getState());
  enterRule(_localctx, 190, ExtendSolidityParser::RuleAssemblyLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    _la = _input->LA(1);
    if (!(((((_la - 98) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 98)) & 134217987) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubAssemblyContext ------------------------------------------------------------------

ExtendSolidityParser::SubAssemblyContext::SubAssemblyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::SubAssemblyContext::identifier() {
  return getRuleContext<ExtendSolidityParser::IdentifierContext>(0);
}

ExtendSolidityParser::AssemblyBlockContext* ExtendSolidityParser::SubAssemblyContext::assemblyBlock() {
  return getRuleContext<ExtendSolidityParser::AssemblyBlockContext>(0);
}


size_t ExtendSolidityParser::SubAssemblyContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleSubAssembly;
}

void ExtendSolidityParser::SubAssemblyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubAssembly(this);
}

void ExtendSolidityParser::SubAssemblyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubAssembly(this);
}


std::any ExtendSolidityParser::SubAssemblyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitSubAssembly(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::SubAssemblyContext* ExtendSolidityParser::subAssembly() {
  SubAssemblyContext *_localctx = _tracker.createInstance<SubAssemblyContext>(_ctx, getState());
  enterRule(_localctx, 192, ExtendSolidityParser::RuleSubAssembly);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1029);
    match(ExtendSolidityParser::T__42);
    setState(1030);
    identifier();
    setState(1031);
    assemblyBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TupleExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::TupleExpressionContext::TupleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::BracketTupleExpressionContext* ExtendSolidityParser::TupleExpressionContext::bracketTupleExpression() {
  return getRuleContext<ExtendSolidityParser::BracketTupleExpressionContext>(0);
}

ExtendSolidityParser::ParanthesesTupleExpressionContext* ExtendSolidityParser::TupleExpressionContext::paranthesesTupleExpression() {
  return getRuleContext<ExtendSolidityParser::ParanthesesTupleExpressionContext>(0);
}


size_t ExtendSolidityParser::TupleExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleTupleExpression;
}

void ExtendSolidityParser::TupleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTupleExpression(this);
}

void ExtendSolidityParser::TupleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTupleExpression(this);
}


std::any ExtendSolidityParser::TupleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitTupleExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::TupleExpressionContext* ExtendSolidityParser::tupleExpression() {
  TupleExpressionContext *_localctx = _tracker.createInstance<TupleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 194, ExtendSolidityParser::RuleTupleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1035);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__20: {
        enterOuterAlt(_localctx, 1);
        setState(1033);
        bracketTupleExpression();
        break;
      }

      case ExtendSolidityParser::T__30: {
        enterOuterAlt(_localctx, 2);
        setState(1034);
        paranthesesTupleExpression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BracketTupleExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::BracketTupleExpressionContext::BracketTupleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::BracketTupleExpressionContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}

std::vector<ExtendSolidityParser::MoreExpressionContext *> ExtendSolidityParser::BracketTupleExpressionContext::moreExpression() {
  return getRuleContexts<ExtendSolidityParser::MoreExpressionContext>();
}

ExtendSolidityParser::MoreExpressionContext* ExtendSolidityParser::BracketTupleExpressionContext::moreExpression(size_t i) {
  return getRuleContext<ExtendSolidityParser::MoreExpressionContext>(i);
}


size_t ExtendSolidityParser::BracketTupleExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleBracketTupleExpression;
}

void ExtendSolidityParser::BracketTupleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBracketTupleExpression(this);
}

void ExtendSolidityParser::BracketTupleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBracketTupleExpression(this);
}


std::any ExtendSolidityParser::BracketTupleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitBracketTupleExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::BracketTupleExpressionContext* ExtendSolidityParser::bracketTupleExpression() {
  BracketTupleExpressionContext *_localctx = _tracker.createInstance<BracketTupleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 196, ExtendSolidityParser::RuleBracketTupleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1037);
    match(ExtendSolidityParser::T__20);

    setState(1039);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(1038);
      expression(0);
    }
    setState(1044);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExtendSolidityParser::T__14) {
      setState(1041);
      moreExpression();
      setState(1046);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1047);
    match(ExtendSolidityParser::T__21);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoreExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::MoreExpressionContext::MoreExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::MoreExpressionContext::expression() {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(0);
}


size_t ExtendSolidityParser::MoreExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleMoreExpression;
}

void ExtendSolidityParser::MoreExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMoreExpression(this);
}

void ExtendSolidityParser::MoreExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMoreExpression(this);
}


std::any ExtendSolidityParser::MoreExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitMoreExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::MoreExpressionContext* ExtendSolidityParser::moreExpression() {
  MoreExpressionContext *_localctx = _tracker.createInstance<MoreExpressionContext>(_ctx, getState());
  enterRule(_localctx, 198, ExtendSolidityParser::RuleMoreExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1049);
    match(ExtendSolidityParser::T__14);
    setState(1051);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(1050);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParanthesesTupleExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::ParanthesesTupleExpressionContext::ParanthesesTupleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExtendSolidityParser::ExpressionContext *> ExtendSolidityParser::ParanthesesTupleExpressionContext::expression() {
  return getRuleContexts<ExtendSolidityParser::ExpressionContext>();
}

ExtendSolidityParser::ExpressionContext* ExtendSolidityParser::ParanthesesTupleExpressionContext::expression(size_t i) {
  return getRuleContext<ExtendSolidityParser::ExpressionContext>(i);
}


size_t ExtendSolidityParser::ParanthesesTupleExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleParanthesesTupleExpression;
}

void ExtendSolidityParser::ParanthesesTupleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParanthesesTupleExpression(this);
}

void ExtendSolidityParser::ParanthesesTupleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParanthesesTupleExpression(this);
}


std::any ExtendSolidityParser::ParanthesesTupleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitParanthesesTupleExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ParanthesesTupleExpressionContext* ExtendSolidityParser::paranthesesTupleExpression() {
  ParanthesesTupleExpressionContext *_localctx = _tracker.createInstance<ParanthesesTupleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 200, ExtendSolidityParser::RuleParanthesesTupleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1053);
    match(ExtendSolidityParser::T__30);
    setState(1062);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -220394346269106160) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3494799899319336961) != 0)) {
      setState(1054);
      expression(0);
      setState(1059);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExtendSolidityParser::T__14) {
        setState(1055);
        match(ExtendSolidityParser::T__14);
        setState(1056);
        expression(0);
        setState(1061);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(1064);
    match(ExtendSolidityParser::T__31);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameExpressionContext ------------------------------------------------------------------

ExtendSolidityParser::TypeNameExpressionContext::TypeNameExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExtendSolidityParser::ElementaryTypeNameContext* ExtendSolidityParser::TypeNameExpressionContext::elementaryTypeName() {
  return getRuleContext<ExtendSolidityParser::ElementaryTypeNameContext>(0);
}

ExtendSolidityParser::UserDefinedTypeNameContext* ExtendSolidityParser::TypeNameExpressionContext::userDefinedTypeName() {
  return getRuleContext<ExtendSolidityParser::UserDefinedTypeNameContext>(0);
}


size_t ExtendSolidityParser::TypeNameExpressionContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleTypeNameExpression;
}

void ExtendSolidityParser::TypeNameExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeNameExpression(this);
}

void ExtendSolidityParser::TypeNameExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeNameExpression(this);
}


std::any ExtendSolidityParser::TypeNameExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitTypeNameExpression(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::TypeNameExpressionContext* ExtendSolidityParser::typeNameExpression() {
  TypeNameExpressionContext *_localctx = _tracker.createInstance<TypeNameExpressionContext>(_ctx, getState());
  enterRule(_localctx, 202, ExtendSolidityParser::RuleTypeNameExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1068);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExtendSolidityParser::T__32:
      case ExtendSolidityParser::T__47:
      case ExtendSolidityParser::T__51:
      case ExtendSolidityParser::T__52:
      case ExtendSolidityParser::T__53:
      case ExtendSolidityParser::Int:
      case ExtendSolidityParser::Uint:
      case ExtendSolidityParser::Byte:
      case ExtendSolidityParser::Fixed:
      case ExtendSolidityParser::Ufixed: {
        enterOuterAlt(_localctx, 1);
        setState(1066);
        elementaryTypeName();
        break;
      }

      case ExtendSolidityParser::T__12:
      case ExtendSolidityParser::T__38:
      case ExtendSolidityParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(1067);
        userDefinedTypeName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberLiteralContext ------------------------------------------------------------------

ExtendSolidityParser::NumberLiteralContext::NumberLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::NumberLiteralContext::DecimalNumber() {
  return getToken(ExtendSolidityParser::DecimalNumber, 0);
}

tree::TerminalNode* ExtendSolidityParser::NumberLiteralContext::HexNumber() {
  return getToken(ExtendSolidityParser::HexNumber, 0);
}

tree::TerminalNode* ExtendSolidityParser::NumberLiteralContext::NumberUnit() {
  return getToken(ExtendSolidityParser::NumberUnit, 0);
}


size_t ExtendSolidityParser::NumberLiteralContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleNumberLiteral;
}

void ExtendSolidityParser::NumberLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberLiteral(this);
}

void ExtendSolidityParser::NumberLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberLiteral(this);
}


std::any ExtendSolidityParser::NumberLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitNumberLiteral(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::NumberLiteralContext* ExtendSolidityParser::numberLiteral() {
  NumberLiteralContext *_localctx = _tracker.createInstance<NumberLiteralContext>(_ctx, getState());
  enterRule(_localctx, 204, ExtendSolidityParser::RuleNumberLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1070);
    _la = _input->LA(1);
    if (!(_la == ExtendSolidityParser::DecimalNumber

    || _la == ExtendSolidityParser::HexNumber)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1072);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      setState(1071);
      match(ExtendSolidityParser::NumberUnit);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

ExtendSolidityParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::IdentifierContext::Identifier() {
  return getToken(ExtendSolidityParser::Identifier, 0);
}


size_t ExtendSolidityParser::IdentifierContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleIdentifier;
}

void ExtendSolidityParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void ExtendSolidityParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}


std::any ExtendSolidityParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::IdentifierContext* ExtendSolidityParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 206, ExtendSolidityParser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1074);
    _la = _input->LA(1);
    if (!(_la == ExtendSolidityParser::T__12

    || _la == ExtendSolidityParser::T__38 || _la == ExtendSolidityParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScopeContext ------------------------------------------------------------------

ExtendSolidityParser::ScopeContext::ScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::ScopeContext::Uint() {
  return getToken(ExtendSolidityParser::Uint, 0);
}


size_t ExtendSolidityParser::ScopeContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleScope;
}

void ExtendSolidityParser::ScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScope(this);
}

void ExtendSolidityParser::ScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScope(this);
}


std::any ExtendSolidityParser::ScopeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitScope(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::ScopeContext* ExtendSolidityParser::scope() {
  ScopeContext *_localctx = _tracker.createInstance<ScopeContext>(_ctx, getState());
  enterRule(_localctx, 208, ExtendSolidityParser::RuleScope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1076);
    match(ExtendSolidityParser::T__48);
    setState(1077);
    _la = _input->LA(1);
    if (!(_la == ExtendSolidityParser::T__32

    || _la == ExtendSolidityParser::T__49 || _la == ExtendSolidityParser::T__92

    || _la == ExtendSolidityParser::Uint)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessSpecifierContext ------------------------------------------------------------------

ExtendSolidityParser::AccessSpecifierContext::AccessSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExtendSolidityParser::AccessSpecifierContext::PublicKeyword() {
  return getToken(ExtendSolidityParser::PublicKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessSpecifierContext::InternalKeyword() {
  return getToken(ExtendSolidityParser::InternalKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessSpecifierContext::PrivateKeyword() {
  return getToken(ExtendSolidityParser::PrivateKeyword, 0);
}

tree::TerminalNode* ExtendSolidityParser::AccessSpecifierContext::ConstantKeyword() {
  return getToken(ExtendSolidityParser::ConstantKeyword, 0);
}


size_t ExtendSolidityParser::AccessSpecifierContext::getRuleIndex() const {
  return ExtendSolidityParser::RuleAccessSpecifier;
}

void ExtendSolidityParser::AccessSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessSpecifier(this);
}

void ExtendSolidityParser::AccessSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExtendSolidityListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessSpecifier(this);
}


std::any ExtendSolidityParser::AccessSpecifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExtendSolidityVisitor*>(visitor))
    return parserVisitor->visitAccessSpecifier(this);
  else
    return visitor->visitChildren(this);
}

ExtendSolidityParser::AccessSpecifierContext* ExtendSolidityParser::accessSpecifier() {
  AccessSpecifierContext *_localctx = _tracker.createInstance<AccessSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 210, ExtendSolidityParser::RuleAccessSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1079);
    _la = _input->LA(1);
    if (!(((((_la - 110) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 110)) & 209) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool ExtendSolidityParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 35: return typeNameSempred(antlrcpp::downCast<TypeNameContext *>(context), predicateIndex);
    case 68: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool ExtendSolidityParser::typeNameSempred(TypeNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool ExtendSolidityParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 3);
    case 2: return precpred(_ctx, 2);
    case 3: return precpred(_ctx, 10);
    case 4: return precpred(_ctx, 9);
    case 5: return precpred(_ctx, 8);
    case 6: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

void ExtendSolidityParser::initialize() {
  ::antlr4::internal::call_once(extendsolidityParserOnceFlag, extendsolidityParserInitialize);
}
